---
title: "Exploration"
output: html_document
date: "2025-05-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
MS_Table_norm = read.table("Datensätze/MS_Table.norm.csv", header=TRUE, row.names=1, sep = ",")
```

```{r}
install.packages("pracma")
```
#Goal: Now we have the normalized values for all proteins and can examine our dataset in detail. Our goal was to identify differences between the control and RNase samples. To do this, we first determined both absolute and local maxima for all proteins. To take it a step further, we wanted to create our own function that can assign each protein to a shift category based on criteria we defined ourselves. So now, let’s take a closer look at our proteins.

# Data exploration

#Vector of fraction names to later insert the names into our mean value tables.
```{r}
Fraktionsnamen = c('Fraction1_Ctrl', 'Fraction1_RNAse', 'Fraction2_Ctrl', 'Fraction2_RNAse','Fraction3_Ctrl', 'Fraction3_RNAse','Fraction4_Ctrl', 'Fraction4_RNAse','Fraction5_Ctrl', 'Fraction5_RNAse','Fraction6_Ctrl', 'Fraction6_RNAse','Fraction7_Ctrl', 'Fraction7_RNAse','Fraction8_Ctrl', 'Fraction8_RNAse','Fraction9_Ctrl', 'Fraction9_RNAse','Fraction10_Ctrl', 'Fraction10_RNAse','Fraction11_Ctrl', 'Fraction11_RNAse','Fraction12_Ctrl', 'Fraction12_RNAse','Fraction13_Ctrl', 'Fraction13_RNAse','Fraction14_Ctrl', 'Fraction14_RNAse','Fraction15_Ctrl', 'Fraction15_RNAse','Fraction16_Ctrl', 'Fraction16_RNAse','Fraction17_Ctrl', 'Fraction17_RNAse','Fraction18_Ctrl', 'Fraction18_RNAse','Fraction19_Ctrl', 'Fraction19_RNAse','Fraction20_Ctrl', 'Fraction20_RNAse','Fraction21_Ctrl', 'Fraction21_RNAse','Fraction22_Ctrl', 'Fraction22_RNAse','Fraction23_Ctrl', 'Fraction23_RNAse','Fraction24_Ctrl', 'Fraction24_RNAse','Fraction25_Ctrl', 'Fraction25_RNAse')
```

```{r}
Proteinnamen = rownames(MS_Table)
```

```{r}
# Subtabellen für jedes Replikat
for (i in 1:6) {

  spalten_index = seq(from = i, to = 150, by = 6) 
  teilmatrix = MS_Table_norm[, spalten_index]
  
  assign(Treatmentnamen[i], teilmatrix) # neue Subtabellen, richtig benannt
}
```

```{r}
# Mittelwerte für Treatments als Tabelle

Mittelwert_matrix = t(apply(MS_Table_norm, 1, function(row) {
  sapply(1:50, function(i) {
    spalten_index = ((i - 1) * 3 + 1):(i * 3)
    mean(row[spalten_index])
  })
}))

# Jeden zweiten Mittelwert auswählen
Mittelwerte_Kontrolle = as.data.frame(Mittelwert_matrix[, seq(1, 50, by=2)])
Mittelwerte_RNAse = as.data.frame(Mittelwert_matrix[, seq(2, 50, by=2)])

colnames(Mittelwerte_Kontrolle) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
colnames(Mittelwerte_RNAse) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
  
```

```{r}
zeile = '4F2_HUMAN'

# Y-Achsen-Limits berechnen
# Werte aus beiden Datensätzen kombinieren
alle_werte <- c(Ctrl1_norm[zeile,], RNAse1_norm[zeile,])
ylim_bereich <- range(alle_werte, na.rm = TRUE)

# Erster Plot mit manuellem ylim
plot(1:25, Ctrl1_norm[zeile,], type = "l", col = 'purple',
     xlab = "fraction", ylab = "Intensity", main = "Proteinverteilung",
     ylim = ylim_bereich)

# Zweiter Plot hinzufügen
lines(1:25, RNAse1_norm[zeile,], col = "darkblue")

# Legende
legend("topright", legend = c("Ctrl1_norm", "RNAse1_norm"),
       col = c("purple", "darkblue"), lty = 1, cex = 0.8)
```

## Maxima Bestimmung

Berücksichtigt: Plateaus, gespaltene Peaks, Randmaxima, Threshold

```{r}
find_maxima = function(mat, threshold = 2) {
  result = do.call(rbind, lapply(1:nrow(mat), function(i) {
    x = mat[i, ]
    
    # Normale Maxima: zweite Ableitung mit Vorzeichenwechsel
    idx = which(diff(sign(diff(x))) == -2) + 1 
    
    # Plateaumaxima
    rle_x = rle(x)  # Run-Length-Encoding der Werte
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    plateau_idx = c()
    for (j in seq_along(values)) {
      # Nur Plateaus mit Länge > 1 prüfen
      if (lengths[j] > 1) {
        start_pos = starts[j]
        end_pos = ends[j]
        
        # Werte links und rechts des Plateaus
        left_val = if (start_pos > 1) x[start_pos - 1] else -Inf
        right_val = if (end_pos < length(x)) x[end_pos + 1] else -Inf
        
        # Plateau ist lokales Maximum, wenn Wert >= Nachbarn
        if (values[j] >= left_val && values[j] >= right_val) {
          # Plateau-Maximum: Indize des Plateausstartpunkts
          plateau_idx = c(plateau_idx, round(mean(start_pos:end_pos)))
        }
      }
    }
    
    # Kombination von normalen Maxima und Plateau-Maxima
    all_idx = sort(unique(c(idx, plateau_idx))) #unique: falls Werte doppelt werden sie entfernt, sort: sotieren der Indizes in aufsteigender Reihenfolge
    
    # Randmaxima prüfen
    if (x[1] > x[2]) {all_idx = c(1, all_idx)}
    if (x[length(x)] > x[length(x)-1]) {all_idx = c(all_idx, length(x))}
    
    # nur Werte > threshold = 2% behalten
    all_idx = all_idx[x[all_idx] > threshold]
    
    # Peaks bereinigen: Wenn zwei Peaks nur einen Wert dazwischen haben, den kleineren entfernen
    if (length(all_idx) >= 2) {
      to_remove = c()
      for (k in 1:(length(all_idx)-1)) {
        if (all_idx[k+1] - all_idx[k] == 2) {
          # Indizes der Peaks
          peak1 = all_idx[k]
          peak2 = all_idx[k+1]
          if (x[peak1] >= x[peak2]) {
            to_remove = c(to_remove, peak2)
          } else {
            to_remove = c(to_remove, peak1)
          }
        }
      } # Entfernen des niedrigeren Wert
      if (length(to_remove) > 0) {
        all_idx = setdiff(all_idx, to_remove)
      }
    }
    
    if (length(all_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = all_idx,
        Wert = x[all_idx]
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}

# Maxima für Mittelwerte aus Triplikaten
Mittelwerte_Kontrolle_mat = as.matrix(sapply(Mittelwerte_Kontrolle, as.numeric))
Mittelwerte_RNAse_mat = as.matrix(sapply(Mittelwerte_RNAse, as.numeric))

Maxima_Mittelwerte_Kontrolle = find_maxima(Mittelwerte_Kontrolle_mat)
Maxima_Mittelwerte_RNAse = find_maxima(Mittelwerte_RNAse_mat)
```

## Schulterpunkte

```{r}
# Funktion zum Finden der Schulterpunkte
find_shoulders = function(binary_mat, Proteinnamen) {
  result = do.call(rbind, lapply(1:nrow(binary_mat), function(i) {
    x = binary_mat[i, ]
    rle_x = rle(x)
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    schulter_idx = c()
    for (j in seq_along(values)) {
      if (values[j] == 1 && lengths[j] >= 4) {
        start_pos = starts[j]
        end_pos = ends[j]
        schulter_idx = c(schulter_idx, round(mean(start_pos:end_pos)))
      }
    }
    
    if (length(schulter_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = schulter_idx
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}
```

### Schulterpunkte für Kontrolle

```{r}
#vorübergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_Kontrolle = ifelse(Mittelwerte_Kontrolle > 2, 1, 0) # wenn größer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vorübergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife über alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_Kontrolle)) {
  Protein = Maxima_Mittelwerte_Kontrolle$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_Kontrolle$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen für die Spalten berechnen (Grenzen prüfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_Kontrolle), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_Kontrolle[Protein, Fraktions_bereich] = 0
}

Schulterpunkte_Kontrolle = find_shoulders(Schulter_Mittelwerte_Kontrolle, Proteinnamen)

```

### Schulterpunkte für RNAse

```{r}
#vorübergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_RNAse = ifelse(Mittelwerte_RNAse > 2, 1, 0) # wenn größer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vorübergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife über alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_RNAse)) {
  Protein = Maxima_Mittelwerte_RNAse$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_RNAse$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen für die Spalten berechnen (Grenzen prüfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_RNAse), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_RNAse[Protein, Fraktions_bereich] = 0
}


Schulterpunkte_RNAse = find_shoulders(Schulter_Mittelwerte_RNAse, Proteinnamen)
```

# es gibt nicht viele Schulterpunkte bei 2,5 die frage ist nur ob wir die entfernen müssen

## Zusammenführen der Werte

Ich würde das nochmal bisschen verändern aber so funktioniert es auf jeden Fall und wir haben Tabellen in denen jetzt alle Maxima & Schulterpunkte haben zum Weiterarbeiten

```{r}
# Für Schulterpunkte Wert hinzufügen
Schulterpunkte_Kontrolle$Fraktion_gerundet = round(Schulterpunkte_Kontrolle$Fraktion)
Schulterpunkte_Kontrolle$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_Kontrolle[zeile, fraktion]
}, Schulterpunkte_Kontrolle$Zeile, Schulterpunkte_Kontrolle$Fraktion_gerundet)

Schulterpunkte_RNAse$Fraktion_gerundet = round(Schulterpunkte_RNAse$Fraktion)
Schulterpunkte_RNAse$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_RNAse[zeile, fraktion]
}, Schulterpunkte_RNAse$Zeile, Schulterpunkte_RNAse$Fraktion_gerundet)


# Markieren und zusammenfügen Kontrolle
Maxima_Mittelwerte_Kontrolle$Typ = "Maxima"
Schulterpunkte_Kontrolle$Typ = "Schulter"

Combined_Kontrolle = rbind(
  Maxima_Mittelwerte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_Kontrolle = Combined_Kontrolle[order(Combined_Kontrolle$Zeile, Combined_Kontrolle$Fraktion), ]

# Markieren und zusammenfügen RNAse
Maxima_Mittelwerte_RNAse$Typ = "Maxima"
Schulterpunkte_RNAse$Typ = "Schulter"

Combined_RNAse = rbind(
  Maxima_Mittelwerte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_RNAse = Combined_RNAse[order(Combined_RNAse$Zeile, Combined_RNAse$Fraktion), ]
```

# Vergleich von RNAse & Kontrolle + Kriterien

### p-Werte für Amplitudendifferenz

```{r}
# P-Werte bestimmen für die verschiedenen Maxima
# Spaltennamen dedr Subtabellen nue benennen, um darauf zugreifen zu können über Combined_Kontrolle und Combined_RNAse
Ctrl1_frakt = Ctrl1_norm
colnames(Ctrl1_frakt) = c(1:25)
Ctrl2_frakt = Ctrl2_norm
colnames(Ctrl2_frakt) = c(1:25)
Ctrl3_frakt = Ctrl3_norm
colnames(Ctrl3_frakt) = c(1:25)

RNAse1_frakt = RNAse1_norm
colnames (RNAse1_frakt) = c(1:25)
RNAse2_frakt = RNAse2_norm
colnames(RNAse2_frakt) = c(1:25)
RNAse3_frakt = RNAse3_norm
colnames(RNAse3_frakt) = c(1:25)

# Listen bilden aus den Replikaten von Kontrolle und RNAse
ctrl_reps = list(Ctrl1_frakt, Ctrl2_frakt, Ctrl3_frakt)
rnase_reps = list(RNAse1_frakt, RNAse2_frakt, RNAse3_frakt)

# Datframe von Kontrolle und RNAse mit nur den Positionen der Peaks
peaks_ctrl = data.frame(Protein = Combined_Kontrolle$Protein, Fraktion = Combined_Kontrolle$Fraktion, Treatment = 'Kontrolle')
peaks_rnase = data.frame(Protein = Combined_RNAse$Protein, Fraktion = Combined_RNAse$Fraktion, Treatment = 'RNase')


# Gemeinsame Protein-Fraktion-Kombinationen von Kontrolle und RNAse bestimmen
shared_peaks = merge(peaks_ctrl, peaks_rnase, by = c("Protein", "Fraktion"))

# Dataframe für die Ergebnisse aufstellen
p_Werte = data.frame()

for (i in 1:nrow(shared_peaks)) {
  protein  = shared_peaks$Protein[i]
  fraktion = as.character(shared_peaks$Fraktion[i])
  
  # Kontrollwerte extrahieren: über Position in shared peaks
  ctrl_vals = sapply(ctrl_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })

  # RNase-Werte extrahieren: über Position in shared peaks
  rnase_vals = sapply(rnase_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })
   # NA Werte entfernen
  ctrl_vals = na.omit(ctrl_vals)
  rnase_vals = na.omit(rnase_vals)

  # Wenn nötig: Mini-Störung hinzufügen bei identischen Werten
  if (length(ctrl_vals) >= 2 && all(abs(ctrl_vals - ctrl_vals[1]) < 1e-10)) {
    ctrl_vals[2] <- ctrl_vals[2] + 1e-6
  }
  if (length(rnase_vals) >= 2 && all(abs(rnase_vals - rnase_vals[1]) < 1e-10)) {
    rnase_vals[2] <- rnase_vals[2] + 1e-6
  }

  # t-Test nur wenn beide Gruppen mindestens 2 Werte haben
  # Annahme für den T-Test, dass Replikate normalverteilt sind, um den T-Test überhaupt durchführen zu können
  # Varianztest mit F-Test, um zu gucken, ob Kontrolle und RNAse gleiche Varianz haben: wichtig für t-Test Durchführung

  if (length(ctrl_vals) >= 2 && length(rnase_vals) >= 2) {
    ftest_p = tryCatch(var.test(ctrl_vals, rnase_vals)$p.value, error = function(e) NA) # nur auf den p.value zugreifen im F-Test
    t_p = tryCatch(
      t.test(ctrl_vals, rnase_vals, var.equal = (ftest_p > 0.05))$p.value, # mögliche Fehler mit tryCatch abfangen
      error = function(e) NA
    )
  } 
  p_Werte = rbind(p_Werte, data.frame(Protein = protein, Fraktion = fraktion, P_Value = t_p))
}


# FDR-Korrektur
p_Werte$adj_p = p.adjust(p_Werte$P_Value, method = "BH")

```

```{r}
p_werte_005 = p_Werte$Protein[which(p_Werte$adj_p <= 0.05)]

```

## Funktion mit allen relevanten paramtern erstellen, die für jedes Protein bestimmt werden

-   maxima werte (amplitude) -\> threshold für relevantes maximum festlegen
-   differenz der amplituden -\> gain (rnase) oder loss (Kontrolle)?
-   proteinmenge (area under the curve) -
-   unterschied in position der maxima - Abstand
-   p werte dazu schreiben


```{r}
liste_maxima_Ctrl = split(Combined_Kontrolle[, c("Fraktion", "Wert")], Combined_Kontrolle$Protein)
liste_maxima_RNAse = split(Combined_RNAse[, c("Fraktion", "Wert")], Combined_RNAse$Protein)

library(pracma)  # Für trapz()

hol_shifts <- function(protein, threshold_rel = 0.3) {
  window <- 2  # Größe des Fraktionsfensters

  # Maxima holen
  ctrl_maxima <- liste_maxima_Ctrl[[protein]]
  rnase_maxima <- liste_maxima_RNAse[[protein]]

  if (is.null(ctrl_maxima)) ctrl_maxima <- data.frame(Fraktion = numeric(0), Wert = numeric(0))
  if (is.null(rnase_maxima)) rnase_maxima <- data.frame(Fraktion = numeric(0), Wert = numeric(0))
  
  if (nrow(ctrl_maxima) > 0) {
    max_ctrl = max(ctrl_maxima$Wert)
    ctrl_maxima = ctrl_maxima[ctrl_maxima$Wert >= threshold_rel * max_ctrl, ]
  }
  
  if (nrow(rnase_maxima) > 0) {
    max_rnase = max(rnase_maxima$Wert)
    rnase_maxima = rnase_maxima[rnase_maxima$Wert >= threshold_rel * max_rnase, ]
  }

  nb_ctrl_maxima <- nrow(ctrl_maxima)
  nb_rnase_maxima <- nrow(rnase_maxima)

  # Abstände der Maxima
  abstände <- c()
  for (i in 1:nb_ctrl_maxima) {
    for (j in 1:nb_rnase_maxima) {
      abstand <- rnase_maxima$Fraktion[j] - ctrl_maxima$Fraktion[i]
      abstände <- c(abstände, abstand)
    }
  }

  # Funktion zur Flächenberechnung mit Trapezregel über Replikat-Dataframes
  calc_area <- function(df_list, protein, center_frac, window) {
    sapply(df_list, function(df) {
      if (protein %in% rownames(df)) {
        fracs <- as.numeric(colnames(df))
        idxs <- which(fracs >= (center_frac - window) & fracs <= (center_frac + window))
        if (length(idxs) >= 2) {
          x_vals <- fracs[idxs]
          y_vals <- as.numeric(df[protein, idxs])
          y_vals <- na.omit(y_vals)
          if (length(y_vals) == length(x_vals) && length(y_vals) >= 2) {
            return(trapz(x_vals, y_vals))
          }
        }
      }
      return(NA)
    })
  }

  # Amplitudenverlust + Fläche unter Kontroll-Peaks
  loss_list <- c()
  flaeche_kontrolle <- c()
  for (i in 1:nb_ctrl_maxima) {
    fraktion_i <- as.character(ctrl_maxima$Fraktion[i])
    amp_ctrl <- ctrl_maxima$Wert[i]

    amp_rnase <- Combined_RNAse$Wert[Combined_RNAse$Protein == protein & Combined_RNAse$Fraktion == fraktion_i]
    if (length(amp_rnase) == 0) amp_rnase <- 0

    loss_list <- c(loss_list, amp_ctrl - amp_rnase)

    flächen_vals <- calc_area(ctrl_reps, protein, as.numeric(fraktion_i), window)
    flaeche_kontrolle <- c(flaeche_kontrolle, mean(na.omit(flächen_vals)))
  }

  # Amplitudengewinn + Fläche unter RNase-Peaks
  gain_list <- c()
  flaeche_rnase <- c()
  for (i in 1:nb_rnase_maxima) {
    fraktion_i <- as.character(rnase_maxima$Fraktion[i])
    amp_rnase <- rnase_maxima$Wert[i]

    amp_ctrl <- Combined_Kontrolle$Wert[Combined_Kontrolle$Protein == protein & Combined_Kontrolle$Fraktion == fraktion_i]
    if (length(amp_ctrl) == 0) amp_ctrl <- 0

    gain_list <- c(gain_list, amp_rnase - amp_ctrl)

    flächen_vals <- calc_area(rnase_reps, protein, as.numeric(fraktion_i), window)
    flaeche_rnase <- c(flaeche_rnase, mean(na.omit(flächen_vals)))
  }

  # p-Werte für Peaks aus vorher berechnetem p_Werte
  p_values <- sapply(ctrl_maxima$Fraktion, function(f) {
    p_val <- p_Werte$adj_p[p_Werte$Protein == protein & p_Werte$Fraktion == f]
    if (length(p_val) == 0) NA else p_val[1]
  })

  return(list(
    Protein = protein,
    Anzahl_Kontroll_Maxima = nb_ctrl_maxima,
    Anzahl_RNase_Maxima = nb_rnase_maxima,
    Abstände_Maxima = abstände,
    Shift_idx = sum(abstände),
    Verlust_Amplituden = loss_list,
    Gewinn_Amplituden = gain_list,
    Summierter_Verlust = sum(loss_list),
    Summierter_Gewinn = sum(gain_list),
    Fläche_Kontrolle = flaeche_kontrolle,
    Fläche_RNase = flaeche_rnase,
    p_Werte = p_values
  ))
}

zeile = '2A5A_HUMAN'

hol_shifts(zeile)
```
Zusammenfügen der Unterlisten zu 

```{r}
proteine = unique(c(names(liste_maxima_Ctrl), names(liste_maxima_RNAse)))

ergebnisse = lapply(proteine, function(p) {
  res = hol_shifts(p)
  
  data.frame(
    Protein = res$Protein,
    Anzahl_Kontroll_Maxima = res$Anzahl_Kontroll_Maxima,
    Anzahl_RNase_Maxima = res$Anzahl_RNase_Maxima,
    Shift_idx = res$Shift_idx,
    Summierter_Verlust = res$Summierter_Verlust,
    Summierter_Gewinn = res$Summierter_Gewinn,
    Abstaende_Maxima = paste(res$Abstände_Maxima, collapse = ";"),
    Verlust_Amplituden = paste(res$Verlust_Amplituden, collapse = ";"),
    Gewinn_Amplituden = paste(res$Gewinn_Amplituden, collapse = ";"),
    Fläche_Kontrolle = paste(res$Fläche_Kontrolle,collapse = ";"),
    Fläche_RNase = paste(res$Fläche_RNase,collapse = ";"),
    p_Werte = paste(res$p_Werte, collapse = ";")
  )
})
df_ergebnisse = do.call(rbind, ergebnisse)


df_ergebnisse = df_ergebnisse[df_ergebnisse$Protein != 'P210L_HUMAN',]
df_ergebnisse = df_ergebnisse[df_ergebnisse$Protein != 'PKD1_HUMAN',]
df_ergebnisse = df_ergebnisse[df_ergebnisse$Protein != 'TGM7_HUMAN',]
df_ergebnisse = df_ergebnisse[df_ergebnisse$Protein != 'KIF1A_HUMAN',]


df_ergebnisse_test = df_ergebnisse
```


# Kriteienfuktion
 
## Funktion für entscheidung über Liste wo das Protein einsortiert wird

-   Kriterien die gegeben sein müssen:

-   p-Wert muss \< 0.05 sein damit signifikant (im Zusammenhang mit gain/loss)

-   Summe der horizontale Differenz der Maximastellen (x-Werte) RNAse - Kontrolle:

    -   =0: kein shift

    -   \<0: left shift

    -   \>0 right shift

wenn das gegeben ist dann 100% ein Shiftendes Protein = RNA-Abhängigkeiten

-   wenn Anzahl an Maxima sich verändert dann shift

- 

wenn horizontale Differnez = 0 aber (veränderung der Anzahl an peaks):
-   gain/loss  !! nochmal genauer!!
- erst verlust dann Gewinn => right
- erst Gewinn dann Verlust => left



```{r}
klassifiziere_protein_shift_streng_v2 <- function(row) {
  parse_numeric_vector <- function(x) {
    if (is.na(x) || is.null(x) || x == "") return(numeric(0))
    suppressWarnings(as.numeric(unlist(strsplit(as.character(x), ";"))))
  }

  get_centroid <- function(x) {
    if (length(x) == 0 || all(is.na(x)) || all(x == 0)) return(NA_real_)
    weighted.mean(seq_along(x), x, na.rm = TRUE)
  }

  score <- 0
  richtung <- NA
  
  ### 1) Shift_idx (max 2 Punkte)
  shift_idx <- suppressWarnings(as.numeric(row[["Shift_idx"]]))
  if (!is.na(shift_idx)) {
    if (abs(shift_idx) >= 2) {
      score <- score + 2
      richtung <- ifelse(shift_idx > 0, "right", "left")
    } else if (abs(shift_idx) == 1) {
      score <- score + 1
      richtung <- ifelse(shift_idx > 0, "right", "left")
    }
  }
  
  ### 2) Maxima Unterschiede (max 2 Punkte)
  max_kontrolle <- suppressWarnings(as.numeric(row[["Anzahl_Kontroll_Maxima"]]))
  max_rnase <- suppressWarnings(as.numeric(row[["Anzahl_RNase_Maxima"]]))
  if (!is.na(max_kontrolle) && !is.na(max_rnase)) {
    diff_maxima <- max_rnase - max_kontrolle
    abs_diff <- abs(diff_maxima)
    if (abs_diff >= 2) {
      score <- score + 2
      if (is.na(richtung)) richtung <- ifelse(diff_maxima > 0, "right", "left")
    } else if (abs_diff == 1) {
      score <- score + 1
      if (is.na(richtung)) richtung <- ifelse(diff_maxima > 0, "right", "left")
    }
  }

  ### 3) p-Werte (Signifikanz gibt PLUS Punkte)
  p_vals <- parse_numeric_vector(row[["p_Werte"]])
  p_vals_vorhanden <- length(p_vals) > 0 && !all(is.na(p_vals))
  signifikant <- p_vals_vorhanden && any(p_vals < 0.05, na.rm = TRUE)
  if (signifikant) {
    score <- score + 2
  } else if (!p_vals_vorhanden) {
    score <- score + 1
    if (is.na(richtung)) richtung <- "right" # default wenn keine Info
  }
  
  ### 4) Flächenbewertung (immer berücksichtigen)
  flaeche_k <- parse_numeric_vector(row[["Fläche_Kontrolle"]])
  flaeche_r <- parse_numeric_vector(row[["Fläche_RNase"]])
  delta_flaeche <- sum(flaeche_r, na.rm = TRUE) - sum(flaeche_k, na.rm = TRUE)
  if (!is.na(delta_flaeche)) {
    if (abs(delta_flaeche) > 30) {
      score <- score + 2
      if (is.na(richtung)) richtung <- ifelse(delta_flaeche > 0, "right", "left")
    } else if (abs(delta_flaeche) > 15) {
      score <- score + 1
      if (is.na(richtung)) richtung <- ifelse(delta_flaeche > 0, "right", "left")
    }
    # Sonderfall: shift_idx == 0 aber große Flächenänderung
    if (!is.na(shift_idx) && shift_idx == 0 && abs(delta_flaeche) > 30) {
      score <- score + 1
    }
    # Zentroidenvergleich
    zentroid_k <- get_centroid(flaeche_k)
    zentroid_r <- get_centroid(flaeche_r)
    if (!is.na(zentroid_k) && !is.na(zentroid_r)) {
      centroid_diff <- zentroid_r - zentroid_k
      if (abs(centroid_diff) >= 2) {
        score <- score + 1
        if (is.na(richtung)) richtung <- ifelse(centroid_diff > 0, "right", "left")
      }
    }
  }
  
  ### 5) Summierter Gewinn/Verlust (nur wenn signifikant)
  if (signifikant) {
    sum_gewinn <- suppressWarnings(as.numeric(row[["Summierter_Gewinn"]]))
    sum_verlust <- suppressWarnings(as.numeric(row[["Summierter_Verlust"]]))
    if (!is.na(sum_gewinn) && !is.na(sum_verlust)) {
      diff_sum <- sum_gewinn - sum_verlust
      if (abs(diff_sum) > 10) {
        score <- score + 1
      }
    }
  }
  
  ### 6) Amplitudenpositionen (nur wenn signifikant)
  if (signifikant) {
    verlust_vec <- parse_numeric_vector(row[["Verlust_Amplituden"]])
    gewinn_vec <- parse_numeric_vector(row[["Gewinn_Amplituden"]])
    if (length(verlust_vec) > 0 && length(gewinn_vec) > 0) {
      v_idx <- which.max(verlust_vec)
      g_idx <- which.max(gewinn_vec)
      if (!is.na(v_idx) && !is.na(g_idx) && v_idx != g_idx) {
        if (is.na(richtung)) {
          richtung <- ifelse(g_idx > v_idx, "right", "left")
        }
        score <- score + 1
      }
    }
  }
  
  if (is.na(richtung)) richtung <- "unbekannt"
  
  ### Kategorie definieren
  if (score >= 5) {
    kategorie <- paste0("starker_", richtung, "_shift")
  } else if (score >= 4) {
    kategorie <- paste0("moderater_", richtung, "_shift")
  } else {
    kategorie <- "kein_shift"
  }
  
  return(list(Score = score, Kategorie = kategorie))
}


ergebnisse_liste <- apply(df_ergebnisse, 1, klassifiziere_protein_shift_streng_v2)
df_ergebnisse$Shift_Score <- sapply(ergebnisse_liste, function(x) x$Score)
df_ergebnisse$Shift_Kategorie <- sapply(ergebnisse_liste, function(x) x$Kategorie)


```



```{r}
vergleich_bewertung <- function(df, auto_spalte = "Shift_Kategorie", manuell_spalte = "Manuelle_Bewertung") {
  # Prüfen, ob Spalten existieren
  if (!(auto_spalte %in% names(df))) stop(paste("Spalte", auto_spalte, "nicht gefunden!"))
  if (!(manuell_spalte %in% names(df))) stop(paste("Spalte", manuell_spalte, "nicht gefunden!"))
  
  # Nur Fälle mit beiden Bewertungen nehmen (keine NA)
  df_vgl <- df[!is.na(df[[auto_spalte]]) & !is.na(df[[manuell_spalte]]), ]
  
  # Anzahl Fälle
  gesamt <- nrow(df_vgl)
  if (gesamt == 0) {
    message("Keine vollständigen Vergleichsdaten gefunden.")
    return(NULL)
  }
  
  # Übereinstimmung prüfen
  korrekt <- sum(df_vgl[[auto_spalte]] == df_vgl[[manuell_spalte]])
  falsch <- gesamt - korrekt
  genauigkeit <- korrekt / gesamt
  
  # Fehlklassifikationen Übersicht (Tabelle)
  tabelle_fehler <- table(Auto = df_vgl[[auto_spalte]], Manuell = df_vgl[[manuell_spalte]])
  
  # Ausgabe
  liste <- list(
    Gesamtfaelle = gesamt,
    Korrekt = korrekt,
    Falsch = falsch,
    Genauigkeit = genauigkeit,
    Fehlklassifikationen = tabelle_fehler
  )
  
  return(liste)
}
ergebnis_vergleich <- vergleich_bewertung(df_ergebnisse_phys, "Shift_Kategorie", "Manuelle_Bewertung")

print(ergebnis_vergleich$Genauigkeit)
print(ergebnis_vergleich$Fehlklassifikationen)

```
```{r}
library(dplyr)

bewertungsmetriken <- function(manuel, auto) {
  labels <- sort(unique(c(levels(factor(manuel)), levels(factor(auto)))))
  
  ergebnisse <- lapply(labels, function(lbl) {
    tp <- sum(manuel == lbl & auto == lbl)
    fp <- sum(manuel != lbl & auto == lbl)
    fn <- sum(manuel == lbl & auto != lbl)
    
    precision <- ifelse(tp + fp == 0, NA, tp / (tp + fp))
    recall <- ifelse(tp + fn == 0, NA, tp / (tp + fn))
    f1 <- ifelse(is.na(precision) | is.na(recall) | (precision + recall) == 0, NA,
                 2 * precision * recall / (precision + recall))
    
    data.frame(Kategorie = lbl, Precision = precision, Recall = recall, F1 = f1)
  })
  
  bind_rows(ergebnisse)
}

library(ggplot2)
library(tidyr)

plot_confusion_matrix <- function(manuel, auto) {
  tab <- table(Auto = auto, Manuell = manuel)
  df_tab <- as.data.frame(tab)
  
  ggplot(df_tab, aes(x = Manuell, y = Auto, fill = Freq)) +
    geom_tile() +
    geom_text(aes(label = Freq), color = "white", size = 4) +
    scale_fill_gradient(low = "lightblue", high = "darkblue") +
    theme_minimal() +
    labs(title = "Confusion Matrix", x = "Manuelle Bewertung", y = "Automatische Bewertung")
}

# Angenommen, du hast diese zwei Spalten in df_ergebnisse:
manuelle_labels <- df_ergebnisse$Manuelle_Bewertung  # z.B. Faktor oder Character
auto_labels <- df_ergebnisse$Shift_Kategorie         # Ergebnis aus deiner Funktion

# Metriken berechnen
metriken <- bewertungsmetriken(manuelle_labels, auto_labels)
print(metriken)

# Confusion Matrix plotten
plot_confusion_matrix(manuelle_labels, auto_labels)

```

```{r}
zeile <- 'ACOT9_HUMAN'

# Y-Achsen-Limits berechnen
alle_werte <- c(Ctrl1_norm[zeile,], RNAse1_norm[zeile,])
ylim_bereich <- range(alle_werte, na.rm = TRUE)

# Mehr Platz oben schaffen (z.B. 15% mehr)
ylim_bereich[2] <- ylim_bereich[2] * 1.15

# Plot vorbereiten
plot(1:25, Ctrl1_norm[zeile,], type = "n",
     xlab = "Fractions", ylab = "Intensity of Proteins", main = paste("Protein distribution:", zeile),
     ylim = ylim_bereich)

# Flächen unter den Kurven
polygon(c(1:25, 25:1),
        c(Ctrl1_norm[zeile,], rep(0, 25)),
        col = adjustcolor("purple", alpha.f = 0.3), border = NA)
lines(1:25, Ctrl1_norm[zeile,], col = "purple", lwd = 2)

polygon(c(1:25, 25:1),
        c(RNAse1_norm[zeile,], rep(0, 25)),
        col = adjustcolor("darkblue", alpha.f = 0.3), border = NA)
lines(1:25, RNAse1_norm[zeile,], col = "darkblue", lwd = 2)

legend("topright", legend = c("Control", "RNAse"),
       col = c("purple", "darkblue"), lwd = 2, cex = 0.6, inset = c(0, -0.05))  # kleiner und etwas weiter nach unten

# Index des aktuellen Proteins in den Tabellen finden
idx_ctrl <- which(abs_Maxima_Mittelwerte_Kontrolle[, 1] == zeile)
idx_rnase <- which(abs_Maxima_Mittelwerte_RNAse[, 1] == zeile)

# Maxima für Kontrolle aus Tabelle holen
max_fraktion_ctrl <- as.numeric(as.character(abs_Maxima_Mittelwerte_Kontrolle[idx_ctrl, 3]))
max_wert_ctrl <- as.numeric(as.character(abs_Maxima_Mittelwerte_Kontrolle[idx_ctrl, 4]))

# Maxima für RNAse aus Tabelle holen
max_fraktion_rnase <- as.numeric(as.character(abs_Maxima_Mittelwerte_RNAse[idx_rnase, 3]))
max_wert_rnase <- as.numeric(as.character(abs_Maxima_Mittelwerte_RNAse[idx_rnase, 4]))

# Vertikale Pfeile für die Maxima
arrows(x0 = max_fraktion_ctrl, y0 = 0,
       x1 = max_fraktion_ctrl, y1 = max_wert_ctrl,
       col = "purple", lwd = 1.5, length = 0.1)

arrows(x0 = max_fraktion_rnase, y0 = 0,
       x1 = max_fraktion_rnase, y1 = max_wert_rnase,
       col = "darkblue", lwd = 1.5, length = 0.1)

# Labels an den Maxima
text(x = max_fraktion_ctrl, y = max_wert_ctrl + 0.10 * max_wert_ctrl,
     labels = "Amplitude", col = "purple", cex = 0.8)

text(x = max_fraktion_rnase, y = max_wert_rnase + 0.05 * max_wert_rnase,
     labels = "Amplitude", col = "darkblue", cex = 0.8)

# Shift-Distance-Pfeil zwischen den Maxima (auf kleinstem Maxima-Niveau)
arrow_y <- min(max_wert_ctrl, max_wert_rnase)

arrows(x0 = max_fraktion_ctrl, y0 = arrow_y,
       x1 = max_fraktion_rnase, y1 = arrow_y,
       col = "black", lwd = 1.6, angle = 15, length = 0.1, code = 3)  # code=3 = beide Enden

# Label für den Shift
text(x = mean(c(max_fraktion_ctrl, max_fraktion_rnase)),
     y = arrow_y + 0.05 * arrow_y,
     labels = "Shift Distance", col = "black", cex = 0.8)

```

```{r}
library(dplyr)
library(ggplot2)

# RBP-Status zuordnen
df_ergebnisse_phys <- df_ergebnisse_phys %>%
  mutate(RBP_Gruppe = ifelse(Shift_Kategorie == "kein_shift", "non-RBP", "RBP"))

# Summen berechnen pro RBP_Gruppe + Shift_Kategorie
df_summary <- df_ergebnisse_phys %>%
  group_by(RBP_Gruppe, Shift_Kategorie) %>%
  summarise(n = n(), .groups = "drop") %>%
  mutate(
    # Kategorie-Label mit Anzahl für die Legende
    Kategorie_mit_n = paste0(Shift_Kategorie, " (", n, ")")
  )

ggplot(df_summary, aes(x = RBP_Gruppe, y = n, fill = Kategorie_mit_n)) +
  geom_col(position = "stack") +
  # Kein geom_text() → keine Zahlen in den Balken
  scale_fill_manual(
    values = setNames(
      c("#A786C2", "#8684C2", "#7396AD", "#728083","#DBCEE6"), 
      df_summary$Kategorie_mit_n
    )
  ) +
  labs(title = "Total Amount of Proteins per Shift category",
       x = "Protein Type", y = "Total Amount of Proteins", fill = "Shift-Kategorie (n)") +
  theme_minimal(base_size = 13)

```


```{r}
library(dplyr)

abs_Maxima_Mittelwerte_Kontrolle <- Maxima_Mittelwerte_Kontrolle %>%
  group_by(Protein) %>%                   # Gruppieren nach Protein
  slice_max(order_by = Wert, n = 1) %>% # Zeile mit maximalem Maxima behalten
  ungroup()

abs_Maxima_Mittelwerte_RNAse <- Maxima_Mittelwerte_RNAse %>%
  group_by(Protein) %>%                   # Gruppieren nach Protein
  slice_max(order_by = Wert, n = 1) %>% # Zeile mit maximalem Maxima behalten
  ungroup()
```

```{r}
merged <- merge(
  abs_Maxima_Mittelwerte_Kontrolle[, c("Protein", "Fraktion")],
  abs_Maxima_Mittelwerte_RNAse[, c("Protein", "Fraktion")],
  by = "Protein",
  suffixes = c("_control", "_rnase")
)

# Berechnung der Anzahl der Punkte über, auf und unter der Linie y = x
above_line <- sum(merged$Fraktion_control > merged$Fraktion_rnase)
on_line <- sum(merged$Fraktion_control == merged$Fraktion_rnase)
below_line <- sum(merged$Fraktion_control < merged$Fraktion_rnase)

# Ausgabe der Werte in der Konsole
cat("Anzahl Proteine über der Linie:", above_line, "\n")
cat("Anzahl Proteine auf der Linie:", on_line, "\n")
cat("Anzahl Proteine unter der Linie:", below_line, "\n")

# Plot nochmal, damit Text eingefügt wird
plot(
  y = merged$Fraktion_control,
  x = merged$Fraktion_rnase,
  xlim = c(0, 25),
  ylim = c(0, 25),
  ylab = "Peaks in the control gradient (Fraction)",
  xlab = "Peaks in the RNase gradient (Fraction)",
  pch = 16, col = rgb(0,0,0,0.5),
  main = "Maxima-Shift der Proteine"
)
abline(0, 1, col = "blue", lty = 2)

# Text mit den Zahlen links unten hinzufügen
text(x = 19, y = 2,
     labels = paste0(
       "left_Shift: ", above_line, "\n",
       "kein_Shift: ", on_line, "\n",
       "right_Shift: ", below_line),
     adj = 0, cex = 0.8, col = "black")

```

#Data_Modelling
```{r}
hist(df_ergebnisse$Shift_Score,
     breaks = 30,
     col = "skyblue",
     main = "Distribution of the Shift Scores",
     xlab = "Shift Score")
```



# App für die Manuelle Bestimmung

```{#r}
library(shiny)

# 📥 Daten laden
if (file.exists("df_ergebnisse_mit_bewertung.RData")) {
  load("df_ergebnisse_mit_bewertung.RData")
} else if (file.exists("df_ergebnisse_original.RData")) {
  load("df_ergebnisse_original.RData")
} else {
  stop("❌ Keine Daten gefunden: Bitte stelle sicher, dass df_ergebnisse vorhanden ist.")
}

# Spalten für Bewertung & Anmerkung hinzufügen, falls noch nicht vorhanden
if (!"Manuelle_Bewertung" %in% colnames(df_ergebnisse)) {
  df_ergebnisse$Manuelle_Bewertung <- NA_character_
}
if (!"Anmerkung" %in% colnames(df_ergebnisse)) {
  df_ergebnisse$Anmerkung <- NA_character_
}

# 🟡 Start bei erstem unbewertetem Protein
start_index <- which(is.na(df_ergebnisse$Manuelle_Bewertung))[1]
if (is.na(start_index)) start_index <- 1

ui <- fluidPage(
  titlePanel("🔬 Manuelle Protein-Bewertung"),
  sidebarLayout(
    sidebarPanel(
      textInput("start_protein_input", "Protein (Name):", value = df_ergebnisse$Protein[start_index]),
      actionButton("go_start", "Suchen"),
      br(), br(),
      actionButton("btn_prev", "← Vorheriges Protein"),
      actionButton("btn_next", "Nächstes Protein →"),
      br(), br(),
      strong(textOutput("protein_position")),  # Anzeige "Protein X von Y"
      strong("Aktuelles Protein:"),
      textOutput("protein_name"),
      br(),
      radioButtons("bewertung", "Kategorie auswählen:",
                   choices = c("kein_shift", "moderater_right_shift", "starker_right_shift",
                               "moderater_left_shift", "starker_left_shift"),
                   selected = character(0)),
      textAreaInput("anmerkung", "Anmerkung (optional):", "", rows = 3),
      actionButton("save", "💾 Bewertung speichern"),
      br(), br(),
      strong("Automatische Kategorie:"),
      textOutput("auto_kat"),
      br(),
      actionButton("exit", "❌ App beenden", class = "btn-danger"),
      br(),
      textOutput("save_status")
    ),
    mainPanel(
      plotOutput("plot", height = "400px")
    )
  )
)

server <- function(input, output, session) {
  current <- reactiveVal(start_index)
  save_status <- reactiveVal("")

  # Springe zum Protein, wenn "go_start" gedrückt wird
  observeEvent(input$go_start, {
    protein_name <- input$start_protein_input
    idx <- which(df_ergebnisse$Protein == protein_name)
    if (length(idx) == 1) {
      current(idx)
      save_status("")
    } else {
      showModal(modalDialog(
        title = "⚠️ Protein nicht gefunden",
        paste0("Protein '", protein_name, "' nicht gefunden. Bitte genau so eingeben wie in der Tabelle."),
        easyClose = TRUE
      ))
    }
  })

  # Eingabefelder aktualisieren, wenn sich aktuelles Protein ändert
  observeEvent(current(), {
    idx <- current()
    updateRadioButtons(session, "bewertung",
                       selected = df_ergebnisse$Manuelle_Bewertung[idx])
    updateTextAreaInput(session, "anmerkung",
                        value = df_ergebnisse$Anmerkung[idx])
    updateTextInput(session, "start_protein_input",
                    value = df_ergebnisse$Protein[idx])
    save_status("")
  })

  observeEvent(input$btn_prev, {
    idx <- current()
    if (idx > 1) current(idx - 1)
  })

  observeEvent(input$btn_next, {
    idx <- current()
    if (idx < nrow(df_ergebnisse)) current(idx + 1)
  })

  output$protein_position <- renderText({
    paste0("Protein ", current(), " von ", nrow(df_ergebnisse))
  })

  output$protein_name <- renderText({
    df_ergebnisse$Protein[current()]
  })

  output$auto_kat <- renderText({
    df_ergebnisse$Shift_Kategorie[current()]
  })

  output$plot <- renderPlot({
    protein_id <- df_ergebnisse$Protein[current()]
    ctrl_vals <- as.numeric(Ctrl1_norm[protein_id, ])
    rnase_vals <- as.numeric(RNAse1_norm[protein_id, ])
    y_range <- range(c(ctrl_vals, rnase_vals), na.rm = TRUE)

    plot(1:length(ctrl_vals), ctrl_vals, type = "l", col = "purple", ylim = y_range,
         xlab = "Fraktion", ylab = "Intensität", main = protein_id)
    lines(1:length(rnase_vals), rnase_vals, col = "darkblue")
    legend("topright", legend = c("Kontrolle", "RNase"), col = c("purple", "darkblue"), lty = 1)
  })

  observeEvent(input$save, {
    idx <- current()
    df_ergebnisse$Manuelle_Bewertung[idx] <<- input$bewertung
    df_ergebnisse$Anmerkung[idx] <<- input$anmerkung
    save(df_ergebnisse, file = "df_ergebnisse_mit_bewertung.RData")
    save_status("💾 Bewertung gespeichert!")
    if (idx < nrow(df_ergebnisse)) {
      current(idx + 1)
    } else {
      showModal(modalDialog("🎉 Letztes Protein erreicht!", easyClose = TRUE))
    }
  })

  # Speichern beim Schließen der Session (z.B. Browser schließen)
  session$onSessionEnded(function() {
    save(df_ergebnisse, file = "df_ergebnisse_mit_bewertung.RData")
  })

  observeEvent(input$exit, {
    save(df_ergebnisse, file = "df_ergebnisse_mit_bewertung.RData")
    stopApp()
  })

  output$save_status <- renderText({
    save_status()
  })
}

shinyApp(ui, server)

```

