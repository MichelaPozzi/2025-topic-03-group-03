---
title: "Exploration"
output: html_document
date: "2025-05-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
MS_Table_norm = read.table("Datens√§tze/MS_Table.norm.csv", header=TRUE, row.names=1, sep = ",")
```

```{r}
install.packages("pracma")
```
#Goal: Now we have the normalized values for all proteins and can examine our dataset in detail. Our goal was to identify differences between the control and RNase samples. To do this, we first determined both absolute and local maxima for all proteins. To take it a step further, we wanted to create our own function that can assign each protein to a shift category based on criteria we defined ourselves. So now, let‚Äôs take a closer look at our proteins.

# Data exploration

#Vector of fraction names to later insert the names into our mean value tables.
```{r}
Fraktionsnamen = c('Fraction1_Ctrl', 'Fraction1_RNAse', 'Fraction2_Ctrl', 'Fraction2_RNAse','Fraction3_Ctrl', 'Fraction3_RNAse','Fraction4_Ctrl', 'Fraction4_RNAse','Fraction5_Ctrl', 'Fraction5_RNAse','Fraction6_Ctrl', 'Fraction6_RNAse','Fraction7_Ctrl', 'Fraction7_RNAse','Fraction8_Ctrl', 'Fraction8_RNAse','Fraction9_Ctrl', 'Fraction9_RNAse','Fraction10_Ctrl', 'Fraction10_RNAse','Fraction11_Ctrl', 'Fraction11_RNAse','Fraction12_Ctrl', 'Fraction12_RNAse','Fraction13_Ctrl', 'Fraction13_RNAse','Fraction14_Ctrl', 'Fraction14_RNAse','Fraction15_Ctrl', 'Fraction15_RNAse','Fraction16_Ctrl', 'Fraction16_RNAse','Fraction17_Ctrl', 'Fraction17_RNAse','Fraction18_Ctrl', 'Fraction18_RNAse','Fraction19_Ctrl', 'Fraction19_RNAse','Fraction20_Ctrl', 'Fraction20_RNAse','Fraction21_Ctrl', 'Fraction21_RNAse','Fraction22_Ctrl', 'Fraction22_RNAse','Fraction23_Ctrl', 'Fraction23_RNAse','Fraction24_Ctrl', 'Fraction24_RNAse','Fraction25_Ctrl', 'Fraction25_RNAse')
```

```{r}
Proteinnamen = rownames(MS_Table)
```

```{r}
# Subtabellen f√ºr jedes Replikat
for (i in 1:6) {

  spalten_index = seq(from = i, to = 150, by = 6) 
  teilmatrix = MS_Table_norm[, spalten_index]
  
  assign(Treatmentnamen[i], teilmatrix) # neue Subtabellen, richtig benannt
}
```

```{r}
# Mittelwerte f√ºr Treatments als Tabelle

Mittelwert_matrix = t(apply(MS_Table_norm, 1, function(row) {
  sapply(1:50, function(i) {
    spalten_index = ((i - 1) * 3 + 1):(i * 3)
    mean(row[spalten_index])
  })
}))

# Jeden zweiten Mittelwert ausw√§hlen
Mittelwerte_Kontrolle = as.data.frame(Mittelwert_matrix[, seq(1, 50, by=2)])
Mittelwerte_RNAse = as.data.frame(Mittelwert_matrix[, seq(2, 50, by=2)])

colnames(Mittelwerte_Kontrolle) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
colnames(Mittelwerte_RNAse) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
  
```

```{r}
zeile = '4F2_HUMAN'

# Y-Achsen-Limits berechnen
# Werte aus beiden Datens√§tzen kombinieren
alle_werte <- c(Ctrl1_norm[zeile,], RNAse1_norm[zeile,])
ylim_bereich <- range(alle_werte, na.rm = TRUE)

# Erster Plot mit manuellem ylim
plot(1:25, Ctrl1_norm[zeile,], type = "l", col = 'purple',
     xlab = "fraction", ylab = "Intensity", main = "Proteinverteilung",
     ylim = ylim_bereich)

# Zweiter Plot hinzuf√ºgen
lines(1:25, RNAse1_norm[zeile,], col = "darkblue")

# Legende
legend("topright", legend = c("Ctrl1_norm", "RNAse1_norm"),
       col = c("purple", "darkblue"), lty = 1, cex = 0.8)
```

## Maxima Bestimmung

Ber√ºcksichtigt: Plateaus, gespaltene Peaks, Randmaxima, Threshold

```{r}
find_maxima = function(mat, threshold = 2) {
  result = do.call(rbind, lapply(1:nrow(mat), function(i) {
    x = mat[i, ]
    
    # Normale Maxima: zweite Ableitung mit Vorzeichenwechsel
    idx = which(diff(sign(diff(x))) == -2) + 1 
    
    # Plateaumaxima
    rle_x = rle(x)  # Run-Length-Encoding der Werte
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    plateau_idx = c()
    for (j in seq_along(values)) {
      # Nur Plateaus mit L√§nge > 1 pr√ºfen
      if (lengths[j] > 1) {
        start_pos = starts[j]
        end_pos = ends[j]
        
        # Werte links und rechts des Plateaus
        left_val = if (start_pos > 1) x[start_pos - 1] else -Inf
        right_val = if (end_pos < length(x)) x[end_pos + 1] else -Inf
        
        # Plateau ist lokales Maximum, wenn Wert >= Nachbarn
        if (values[j] >= left_val && values[j] >= right_val) {
          # Plateau-Maximum: Indize des Plateausstartpunkts
          plateau_idx = c(plateau_idx, round(mean(start_pos:end_pos)))
        }
      }
    }
    
    # Kombination von normalen Maxima und Plateau-Maxima
    all_idx = sort(unique(c(idx, plateau_idx))) #unique: falls Werte doppelt werden sie entfernt, sort: sotieren der Indizes in aufsteigender Reihenfolge
    
    # Randmaxima pr√ºfen
    if (x[1] > x[2]) {all_idx = c(1, all_idx)}
    if (x[length(x)] > x[length(x)-1]) {all_idx = c(all_idx, length(x))}
    
    # nur Werte > threshold = 2% behalten
    all_idx = all_idx[x[all_idx] > threshold]
    
    # Peaks bereinigen: Wenn zwei Peaks nur einen Wert dazwischen haben, den kleineren entfernen
    if (length(all_idx) >= 2) {
      to_remove = c()
      for (k in 1:(length(all_idx)-1)) {
        if (all_idx[k+1] - all_idx[k] == 2) {
          # Indizes der Peaks
          peak1 = all_idx[k]
          peak2 = all_idx[k+1]
          if (x[peak1] >= x[peak2]) {
            to_remove = c(to_remove, peak2)
          } else {
            to_remove = c(to_remove, peak1)
          }
        }
      } # Entfernen des niedrigeren Wert
      if (length(to_remove) > 0) {
        all_idx = setdiff(all_idx, to_remove)
      }
    }
    
    if (length(all_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = all_idx,
        Wert = x[all_idx]
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}

# Maxima f√ºr Mittelwerte aus Triplikaten
Mittelwerte_Kontrolle_mat = as.matrix(sapply(Mittelwerte_Kontrolle, as.numeric))
Mittelwerte_RNAse_mat = as.matrix(sapply(Mittelwerte_RNAse, as.numeric))

Maxima_Mittelwerte_Kontrolle = find_maxima(Mittelwerte_Kontrolle_mat)
Maxima_Mittelwerte_RNAse = find_maxima(Mittelwerte_RNAse_mat)
```

## Schulterpunkte

```{r}
# Funktion zum Finden der Schulterpunkte
find_shoulders = function(binary_mat, Proteinnamen) {
  result = do.call(rbind, lapply(1:nrow(binary_mat), function(i) {
    x = binary_mat[i, ]
    rle_x = rle(x)
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    schulter_idx = c()
    for (j in seq_along(values)) {
      if (values[j] == 1 && lengths[j] >= 4) {
        start_pos = starts[j]
        end_pos = ends[j]
        schulter_idx = c(schulter_idx, round(mean(start_pos:end_pos)))
      }
    }
    
    if (length(schulter_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = schulter_idx
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}
```

### Schulterpunkte f√ºr Kontrolle

```{r}
#vor√ºbergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_Kontrolle = ifelse(Mittelwerte_Kontrolle > 2, 1, 0) # wenn gr√∂√üer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vor√ºbergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife √ºber alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_Kontrolle)) {
  Protein = Maxima_Mittelwerte_Kontrolle$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_Kontrolle$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen f√ºr die Spalten berechnen (Grenzen pr√ºfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_Kontrolle), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ¬±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_Kontrolle[Protein, Fraktions_bereich] = 0
}

Schulterpunkte_Kontrolle = find_shoulders(Schulter_Mittelwerte_Kontrolle, Proteinnamen)

```

### Schulterpunkte f√ºr RNAse

```{r}
#vor√ºbergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_RNAse = ifelse(Mittelwerte_RNAse > 2, 1, 0) # wenn gr√∂√üer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vor√ºbergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife √ºber alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_RNAse)) {
  Protein = Maxima_Mittelwerte_RNAse$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_RNAse$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen f√ºr die Spalten berechnen (Grenzen pr√ºfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_RNAse), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ¬±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_RNAse[Protein, Fraktions_bereich] = 0
}


Schulterpunkte_RNAse = find_shoulders(Schulter_Mittelwerte_RNAse, Proteinnamen)
```

# es gibt nicht viele Schulterpunkte bei 2,5 die frage ist nur ob wir die entfernen m√ºssen

## Zusammenf√ºhren der Werte

Ich w√ºrde das nochmal bisschen ver√§ndern aber so funktioniert es auf jeden Fall und wir haben Tabellen in denen jetzt alle Maxima & Schulterpunkte haben zum Weiterarbeiten

```{r}
# F√ºr Schulterpunkte Wert hinzuf√ºgen
Schulterpunkte_Kontrolle$Fraktion_gerundet = round(Schulterpunkte_Kontrolle$Fraktion)
Schulterpunkte_Kontrolle$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_Kontrolle[zeile, fraktion]
}, Schulterpunkte_Kontrolle$Zeile, Schulterpunkte_Kontrolle$Fraktion_gerundet)

Schulterpunkte_RNAse$Fraktion_gerundet = round(Schulterpunkte_RNAse$Fraktion)
Schulterpunkte_RNAse$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_RNAse[zeile, fraktion]
}, Schulterpunkte_RNAse$Zeile, Schulterpunkte_RNAse$Fraktion_gerundet)


# Markieren und zusammenf√ºgen Kontrolle
Maxima_Mittelwerte_Kontrolle$Typ = "Maxima"
Schulterpunkte_Kontrolle$Typ = "Schulter"

Combined_Kontrolle = rbind(
  Maxima_Mittelwerte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_Kontrolle = Combined_Kontrolle[order(Combined_Kontrolle$Zeile, Combined_Kontrolle$Fraktion), ]

# Markieren und zusammenf√ºgen RNAse
Maxima_Mittelwerte_RNAse$Typ = "Maxima"
Schulterpunkte_RNAse$Typ = "Schulter"

Combined_RNAse = rbind(
  Maxima_Mittelwerte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_RNAse = Combined_RNAse[order(Combined_RNAse$Zeile, Combined_RNAse$Fraktion), ]
```

# Vergleich von RNAse & Kontrolle + Kriterien

### p-Werte f√ºr Amplitudendifferenz

```{r}
# P-Werte bestimmen f√ºr die verschiedenen Maxima
# Spaltennamen dedr Subtabellen nue benennen, um darauf zugreifen zu k√∂nnen √ºber Combined_Kontrolle und Combined_RNAse
Ctrl1_frakt = Ctrl1_norm
colnames(Ctrl1_frakt) = c(1:25)
Ctrl2_frakt = Ctrl2_norm
colnames(Ctrl2_frakt) = c(1:25)
Ctrl3_frakt = Ctrl3_norm
colnames(Ctrl3_frakt) = c(1:25)

RNAse1_frakt = RNAse1_norm
colnames (RNAse1_frakt) = c(1:25)
RNAse2_frakt = RNAse2_norm
colnames(RNAse2_frakt) = c(1:25)
RNAse3_frakt = RNAse3_norm
colnames(RNAse3_frakt) = c(1:25)

# Listen bilden aus den Replikaten von Kontrolle und RNAse
ctrl_reps = list(Ctrl1_frakt, Ctrl2_frakt, Ctrl3_frakt)
rnase_reps = list(RNAse1_frakt, RNAse2_frakt, RNAse3_frakt)

# Datframe von Kontrolle und RNAse mit nur den Positionen der Peaks
peaks_ctrl = data.frame(Protein = Combined_Kontrolle$Protein, Fraktion = Combined_Kontrolle$Fraktion, Treatment = 'Kontrolle')
peaks_rnase = data.frame(Protein = Combined_RNAse$Protein, Fraktion = Combined_RNAse$Fraktion, Treatment = 'RNase')


# Gemeinsame Protein-Fraktion-Kombinationen von Kontrolle und RNAse bestimmen
shared_peaks = merge(peaks_ctrl, peaks_rnase, by = c("Protein", "Fraktion"))

# Dataframe f√ºr die Ergebnisse aufstellen
p_Werte = data.frame()

for (i in 1:nrow(shared_peaks)) {
  protein  = shared_peaks$Protein[i]
  fraktion = as.character(shared_peaks$Fraktion[i])
  
  # Kontrollwerte extrahieren: √ºber Position in shared peaks
  ctrl_vals = sapply(ctrl_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })

  # RNase-Werte extrahieren: √ºber Position in shared peaks
  rnase_vals = sapply(rnase_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })
   # NA Werte entfernen
  ctrl_vals = na.omit(ctrl_vals)
  rnase_vals = na.omit(rnase_vals)

  # Wenn n√∂tig: Mini-St√∂rung hinzuf√ºgen bei identischen Werten
  if (length(ctrl_vals) >= 2 && all(abs(ctrl_vals - ctrl_vals[1]) < 1e-10)) {
    ctrl_vals[2] <- ctrl_vals[2] + 1e-6
  }
  if (length(rnase_vals) >= 2 && all(abs(rnase_vals - rnase_vals[1]) < 1e-10)) {
    rnase_vals[2] <- rnase_vals[2] + 1e-6
  }

  # t-Test nur wenn beide Gruppen mindestens 2 Werte haben
  # Annahme f√ºr den T-Test, dass Replikate normalverteilt sind, um den T-Test √ºberhaupt durchf√ºhren zu k√∂nnen
  # Varianztest mit F-Test, um zu gucken, ob Kontrolle und RNAse gleiche Varianz haben: wichtig f√ºr t-Test Durchf√ºhrung

  if (length(ctrl_vals) >= 2 && length(rnase_vals) >= 2) {
    ftest_p = tryCatch(var.test(ctrl_vals, rnase_vals)$p.value, error = function(e) NA) # nur auf den p.value zugreifen im F-Test
    t_p = tryCatch(
      t.test(ctrl_vals, rnase_vals, var.equal = (ftest_p > 0.05))$p.value, # m√∂gliche Fehler mit tryCatch abfangen
      error = function(e) NA
    )
  } 
  p_Werte = rbind(p_Werte, data.frame(Protein = protein, Fraktion = fraktion, P_Value = t_p))
}


# FDR-Korrektur
p_Werte$adj_p = p.adjust(p_Werte$P_Value, method = "BH")

```

```{r}
p_werte_005 = p_Werte$Protein[which(p_Werte$adj_p <= 0.05)]

```

## Funktion mit allen relevanten paramtern erstellen, die f√ºr jedes Protein bestimmt werden

-   maxima werte (amplitude) -\> threshold f√ºr relevantes maximum festlegen
-   differenz der amplituden -\> gain (rnase) oder loss (Kontrolle)?
-   proteinmenge (area under the curve) -
-   unterschied in position der maxima - Abstand
-   p werte dazu schreiben


```{r}
liste_maxima_Ctrl = split(Combined_Kontrolle[, c("Fraktion", "Wert")], Combined_Kontrolle$Protein)
liste_maxima_RNAse = split(Combined_RNAse[, c("Fraktion", "Wert")], Combined_RNAse$Protein)

library(pracma)  # F√ºr trapz()

hol_shifts <- function(protein, threshold_rel = 0.3) {
  window <- 2  # Gr√∂√üe des Fraktionsfensters

  # Maxima holen
  ctrl_maxima <- liste_maxima_Ctrl[[protein]]
  rnase_maxima <- liste_maxima_RNAse[[protein]]

  if (is.null(ctrl_maxima)) ctrl_maxima <- data.frame(Fraktion = numeric(0), Wert = numeric(0))
  if (is.null(rnase_maxima)) rnase_maxima <- data.frame(Fraktion = numeric(0), Wert = numeric(0))
  
  if (nrow(ctrl_maxima) > 0) {
    max_ctrl = max(ctrl_maxima$Wert)
    ctrl_maxima = ctrl_maxima[ctrl_maxima$Wert >= threshold_rel * max_ctrl, ]
  }
  
  if (nrow(rnase_maxima) > 0) {
    max_rnase = max(rnase_maxima$Wert)
    rnase_maxima = rnase_maxima[rnase_maxima$Wert >= threshold_rel * max_rnase, ]
  }

  nb_ctrl_maxima <- nrow(ctrl_maxima)
  nb_rnase_maxima <- nrow(rnase_maxima)

  # Abst√§nde der Maxima
  abst√§nde <- c()
  for (i in 1:nb_ctrl_maxima) {
    for (j in 1:nb_rnase_maxima) {
      abstand <- rnase_maxima$Fraktion[j] - ctrl_maxima$Fraktion[i]
      abst√§nde <- c(abst√§nde, abstand)
    }
  }

  # Funktion zur Fl√§chenberechnung mit Trapezregel √ºber Replikat-Dataframes
  calc_area <- function(df_list, protein, center_frac, window) {
    sapply(df_list, function(df) {
      if (protein %in% rownames(df)) {
        fracs <- as.numeric(colnames(df))
        idxs <- which(fracs >= (center_frac - window) & fracs <= (center_frac + window))
        if (length(idxs) >= 2) {
          x_vals <- fracs[idxs]
          y_vals <- as.numeric(df[protein, idxs])
          y_vals <- na.omit(y_vals)
          if (length(y_vals) == length(x_vals) && length(y_vals) >= 2) {
            return(trapz(x_vals, y_vals))
          }
        }
      }
      return(NA)
    })
  }

  # Amplitudenverlust + Fl√§che unter Kontroll-Peaks
  loss_list <- c()
  flaeche_kontrolle <- c()
  for (i in 1:nb_ctrl_maxima) {
    fraktion_i <- as.character(ctrl_maxima$Fraktion[i])
    amp_ctrl <- ctrl_maxima$Wert[i]

    amp_rnase <- Combined_RNAse$Wert[Combined_RNAse$Protein == protein & Combined_RNAse$Fraktion == fraktion_i]
    if (length(amp_rnase) == 0) amp_rnase <- 0

    loss_list <- c(loss_list, amp_ctrl - amp_rnase)

    fl√§chen_vals <- calc_area(ctrl_reps, protein, as.numeric(fraktion_i), window)
    flaeche_kontrolle <- c(flaeche_kontrolle, mean(na.omit(fl√§chen_vals)))
  }

  # Amplitudengewinn + Fl√§che unter RNase-Peaks
  gain_list <- c()
  flaeche_rnase <- c()
  for (i in 1:nb_rnase_maxima) {
    fraktion_i <- as.character(rnase_maxima$Fraktion[i])
    amp_rnase <- rnase_maxima$Wert[i]

    amp_ctrl <- Combined_Kontrolle$Wert[Combined_Kontrolle$Protein == protein & Combined_Kontrolle$Fraktion == fraktion_i]
    if (length(amp_ctrl) == 0) amp_ctrl <- 0

    gain_list <- c(gain_list, amp_rnase - amp_ctrl)

    fl√§chen_vals <- calc_area(rnase_reps, protein, as.numeric(fraktion_i), window)
    flaeche_rnase <- c(flaeche_rnase, mean(na.omit(fl√§chen_vals)))
  }

  # p-Werte f√ºr Peaks aus vorher berechnetem p_Werte
  p_values <- sapply(ctrl_maxima$Fraktion, function(f) {
    p_val <- p_Werte$adj_p[p_Werte$Protein == protein & p_Werte$Fraktion == f]
    if (length(p_val) == 0) NA else p_val[1]
  })

  return(list(
    Protein = protein,
    Anzahl_Kontroll_Maxima = nb_ctrl_maxima,
    Anzahl_RNase_Maxima = nb_rnase_maxima,
    Abst√§nde_Maxima = abst√§nde,
    Shift_idx = sum(abst√§nde),
    Verlust_Amplituden = loss_list,
    Gewinn_Amplituden = gain_list,
    Summierter_Verlust = sum(loss_list),
    Summierter_Gewinn = sum(gain_list),
    Fl√§che_Kontrolle = flaeche_kontrolle,
    Fl√§che_RNase = flaeche_rnase,
    p_Werte = p_values
  ))
}

zeile = '2A5A_HUMAN'

hol_shifts(zeile)
```
Zusammenf√ºgen der Unterlisten zu 

```{r}
proteine = unique(c(names(liste_maxima_Ctrl), names(liste_maxima_RNAse)))

ergebnisse = lapply(proteine, function(p) {
  res = hol_shifts(p)
  
  data.frame(
    Protein = res$Protein,
    Anzahl_Kontroll_Maxima = res$Anzahl_Kontroll_Maxima,
    Anzahl_RNase_Maxima = res$Anzahl_RNase_Maxima,
    Shift_idx = res$Shift_idx,
    Summierter_Verlust = res$Summierter_Verlust,
    Summierter_Gewinn = res$Summierter_Gewinn,
    Abstaende_Maxima = paste(res$Abst√§nde_Maxima, collapse = ";"),
    Verlust_Amplituden = paste(res$Verlust_Amplituden, collapse = ";"),
    Gewinn_Amplituden = paste(res$Gewinn_Amplituden, collapse = ";"),
    Fl√§che_Kontrolle = paste(res$Fl√§che_Kontrolle,collapse = ";"),
    Fl√§che_RNase = paste(res$Fl√§che_RNase,collapse = ";"),
    p_Werte = paste(res$p_Werte, collapse = ";")
  )
})
df_ergebnisse = do.call(rbind, ergebnisse)


df_ergebnisse = df_ergebnisse[df_ergebnisse$Protein != 'P210L_HUMAN',]
df_ergebnisse = df_ergebnisse[df_ergebnisse$Protein != 'PKD1_HUMAN',]
df_ergebnisse = df_ergebnisse[df_ergebnisse$Protein != 'TGM7_HUMAN',]
df_ergebnisse = df_ergebnisse[df_ergebnisse$Protein != 'KIF1A_HUMAN',]


df_ergebnisse_test = df_ergebnisse
```


# Kriteienfuktion
 
## Funktion f√ºr entscheidung √ºber Liste wo das Protein einsortiert wird

-   Kriterien die gegeben sein m√ºssen:

-   p-Wert muss \< 0.05 sein damit signifikant (im Zusammenhang mit gain/loss)

-   Summe der horizontale Differenz der Maximastellen (x-Werte) RNAse - Kontrolle:

    -   =0: kein shift

    -   \<0: left shift

    -   \>0 right shift

wenn das gegeben ist dann 100% ein Shiftendes Protein = RNA-Abh√§ngigkeiten

-   wenn Anzahl an Maxima sich ver√§ndert dann shift

- 

wenn horizontale Differnez = 0 aber (ver√§nderung der Anzahl an peaks):
-   gain/loss  !! nochmal genauer!!
- erst verlust dann Gewinn => right
- erst Gewinn dann Verlust => left



```{r}
klassifiziere_protein_shift_streng_v2 <- function(row) {
  parse_numeric_vector <- function(x) {
    if (is.na(x) || is.null(x) || x == "") return(numeric(0))
    suppressWarnings(as.numeric(unlist(strsplit(as.character(x), ";"))))
  }

  get_centroid <- function(x) {
    if (length(x) == 0 || all(is.na(x)) || all(x == 0)) return(NA_real_)
    weighted.mean(seq_along(x), x, na.rm = TRUE)
  }

  score <- 0
  richtung <- NA
  
  ### 1) Shift_idx (max 2 Punkte)
  shift_idx <- suppressWarnings(as.numeric(row[["Shift_idx"]]))
  if (!is.na(shift_idx)) {
    if (abs(shift_idx) >= 2) {
      score <- score + 2
      richtung <- ifelse(shift_idx > 0, "right", "left")
    } else if (abs(shift_idx) == 1) {
      score <- score + 1
      richtung <- ifelse(shift_idx > 0, "right", "left")
    }
  }
  
  ### 2) Maxima Unterschiede (max 2 Punkte)
  max_kontrolle <- suppressWarnings(as.numeric(row[["Anzahl_Kontroll_Maxima"]]))
  max_rnase <- suppressWarnings(as.numeric(row[["Anzahl_RNase_Maxima"]]))
  if (!is.na(max_kontrolle) && !is.na(max_rnase)) {
    diff_maxima <- max_rnase - max_kontrolle
    abs_diff <- abs(diff_maxima)
    if (abs_diff >= 2) {
      score <- score + 2
      if (is.na(richtung)) richtung <- ifelse(diff_maxima > 0, "right", "left")
    } else if (abs_diff == 1) {
      score <- score + 1
      if (is.na(richtung)) richtung <- ifelse(diff_maxima > 0, "right", "left")
    }
  }

  ### 3) p-Werte (Signifikanz gibt PLUS Punkte)
  p_vals <- parse_numeric_vector(row[["p_Werte"]])
  p_vals_vorhanden <- length(p_vals) > 0 && !all(is.na(p_vals))
  signifikant <- p_vals_vorhanden && any(p_vals < 0.05, na.rm = TRUE)
  if (signifikant) {
    score <- score + 2
  } else if (!p_vals_vorhanden) {
    score <- score + 1
    if (is.na(richtung)) richtung <- "right" # default wenn keine Info
  }
  
  ### 4) Fl√§chenbewertung (immer ber√ºcksichtigen)
  flaeche_k <- parse_numeric_vector(row[["Fl√§che_Kontrolle"]])
  flaeche_r <- parse_numeric_vector(row[["Fl√§che_RNase"]])
  delta_flaeche <- sum(flaeche_r, na.rm = TRUE) - sum(flaeche_k, na.rm = TRUE)
  if (!is.na(delta_flaeche)) {
    if (abs(delta_flaeche) > 30) {
      score <- score + 2
      if (is.na(richtung)) richtung <- ifelse(delta_flaeche > 0, "right", "left")
    } else if (abs(delta_flaeche) > 15) {
      score <- score + 1
      if (is.na(richtung)) richtung <- ifelse(delta_flaeche > 0, "right", "left")
    }
    # Sonderfall: shift_idx == 0 aber gro√üe Fl√§chen√§nderung
    if (!is.na(shift_idx) && shift_idx == 0 && abs(delta_flaeche) > 30) {
      score <- score + 1
    }
    # Zentroidenvergleich
    zentroid_k <- get_centroid(flaeche_k)
    zentroid_r <- get_centroid(flaeche_r)
    if (!is.na(zentroid_k) && !is.na(zentroid_r)) {
      centroid_diff <- zentroid_r - zentroid_k
      if (abs(centroid_diff) >= 2) {
        score <- score + 1
        if (is.na(richtung)) richtung <- ifelse(centroid_diff > 0, "right", "left")
      }
    }
  }
  
  ### 5) Summierter Gewinn/Verlust (nur wenn signifikant)
  if (signifikant) {
    sum_gewinn <- suppressWarnings(as.numeric(row[["Summierter_Gewinn"]]))
    sum_verlust <- suppressWarnings(as.numeric(row[["Summierter_Verlust"]]))
    if (!is.na(sum_gewinn) && !is.na(sum_verlust)) {
      diff_sum <- sum_gewinn - sum_verlust
      if (abs(diff_sum) > 10) {
        score <- score + 1
      }
    }
  }
  
  ### 6) Amplitudenpositionen (nur wenn signifikant)
  if (signifikant) {
    verlust_vec <- parse_numeric_vector(row[["Verlust_Amplituden"]])
    gewinn_vec <- parse_numeric_vector(row[["Gewinn_Amplituden"]])
    if (length(verlust_vec) > 0 && length(gewinn_vec) > 0) {
      v_idx <- which.max(verlust_vec)
      g_idx <- which.max(gewinn_vec)
      if (!is.na(v_idx) && !is.na(g_idx) && v_idx != g_idx) {
        if (is.na(richtung)) {
          richtung <- ifelse(g_idx > v_idx, "right", "left")
        }
        score <- score + 1
      }
    }
  }
  
  if (is.na(richtung)) richtung <- "unbekannt"
  
  ### Kategorie definieren
  if (score >= 5) {
    kategorie <- paste0("starker_", richtung, "_shift")
  } else if (score >= 4) {
    kategorie <- paste0("moderater_", richtung, "_shift")
  } else {
    kategorie <- "kein_shift"
  }
  
  return(list(Score = score, Kategorie = kategorie))
}


ergebnisse_liste <- apply(df_ergebnisse, 1, klassifiziere_protein_shift_streng_v2)
df_ergebnisse$Shift_Score <- sapply(ergebnisse_liste, function(x) x$Score)
df_ergebnisse$Shift_Kategorie <- sapply(ergebnisse_liste, function(x) x$Kategorie)


```



```{r}
vergleich_bewertung <- function(df, auto_spalte = "Shift_Kategorie", manuell_spalte = "Manuelle_Bewertung") {
  # Pr√ºfen, ob Spalten existieren
  if (!(auto_spalte %in% names(df))) stop(paste("Spalte", auto_spalte, "nicht gefunden!"))
  if (!(manuell_spalte %in% names(df))) stop(paste("Spalte", manuell_spalte, "nicht gefunden!"))
  
  # Nur F√§lle mit beiden Bewertungen nehmen (keine NA)
  df_vgl <- df[!is.na(df[[auto_spalte]]) & !is.na(df[[manuell_spalte]]), ]
  
  # Anzahl F√§lle
  gesamt <- nrow(df_vgl)
  if (gesamt == 0) {
    message("Keine vollst√§ndigen Vergleichsdaten gefunden.")
    return(NULL)
  }
  
  # √úbereinstimmung pr√ºfen
  korrekt <- sum(df_vgl[[auto_spalte]] == df_vgl[[manuell_spalte]])
  falsch <- gesamt - korrekt
  genauigkeit <- korrekt / gesamt
  
  # Fehlklassifikationen √úbersicht (Tabelle)
  tabelle_fehler <- table(Auto = df_vgl[[auto_spalte]], Manuell = df_vgl[[manuell_spalte]])
  
  # Ausgabe
  liste <- list(
    Gesamtfaelle = gesamt,
    Korrekt = korrekt,
    Falsch = falsch,
    Genauigkeit = genauigkeit,
    Fehlklassifikationen = tabelle_fehler
  )
  
  return(liste)
}
ergebnis_vergleich <- vergleich_bewertung(df_ergebnisse_phys, "Shift_Kategorie", "Manuelle_Bewertung")

print(ergebnis_vergleich$Genauigkeit)
print(ergebnis_vergleich$Fehlklassifikationen)

```
```{r}
library(dplyr)

bewertungsmetriken <- function(manuel, auto) {
  labels <- sort(unique(c(levels(factor(manuel)), levels(factor(auto)))))
  
  ergebnisse <- lapply(labels, function(lbl) {
    tp <- sum(manuel == lbl & auto == lbl)
    fp <- sum(manuel != lbl & auto == lbl)
    fn <- sum(manuel == lbl & auto != lbl)
    
    precision <- ifelse(tp + fp == 0, NA, tp / (tp + fp))
    recall <- ifelse(tp + fn == 0, NA, tp / (tp + fn))
    f1 <- ifelse(is.na(precision) | is.na(recall) | (precision + recall) == 0, NA,
                 2 * precision * recall / (precision + recall))
    
    data.frame(Kategorie = lbl, Precision = precision, Recall = recall, F1 = f1)
  })
  
  bind_rows(ergebnisse)
}

library(ggplot2)
library(tidyr)

plot_confusion_matrix <- function(manuel, auto) {
  tab <- table(Auto = auto, Manuell = manuel)
  df_tab <- as.data.frame(tab)
  
  ggplot(df_tab, aes(x = Manuell, y = Auto, fill = Freq)) +
    geom_tile() +
    geom_text(aes(label = Freq), color = "white", size = 4) +
    scale_fill_gradient(low = "lightblue", high = "darkblue") +
    theme_minimal() +
    labs(title = "Confusion Matrix", x = "Manuelle Bewertung", y = "Automatische Bewertung")
}

# Angenommen, du hast diese zwei Spalten in df_ergebnisse:
manuelle_labels <- df_ergebnisse$Manuelle_Bewertung  # z.B. Faktor oder Character
auto_labels <- df_ergebnisse$Shift_Kategorie         # Ergebnis aus deiner Funktion

# Metriken berechnen
metriken <- bewertungsmetriken(manuelle_labels, auto_labels)
print(metriken)

# Confusion Matrix plotten
plot_confusion_matrix(manuelle_labels, auto_labels)

```

```{r}
zeile <- 'ACOT9_HUMAN'

# Y-Achsen-Limits berechnen
alle_werte <- c(Ctrl1_norm[zeile,], RNAse1_norm[zeile,])
ylim_bereich <- range(alle_werte, na.rm = TRUE)

# Mehr Platz oben schaffen (z.B. 15% mehr)
ylim_bereich[2] <- ylim_bereich[2] * 1.15

# Plot vorbereiten
plot(1:25, Ctrl1_norm[zeile,], type = "n",
     xlab = "Fractions", ylab = "Intensity of Proteins", main = paste("Protein distribution:", zeile),
     ylim = ylim_bereich)

# Fl√§chen unter den Kurven
polygon(c(1:25, 25:1),
        c(Ctrl1_norm[zeile,], rep(0, 25)),
        col = adjustcolor("purple", alpha.f = 0.3), border = NA)
lines(1:25, Ctrl1_norm[zeile,], col = "purple", lwd = 2)

polygon(c(1:25, 25:1),
        c(RNAse1_norm[zeile,], rep(0, 25)),
        col = adjustcolor("darkblue", alpha.f = 0.3), border = NA)
lines(1:25, RNAse1_norm[zeile,], col = "darkblue", lwd = 2)

legend("topright", legend = c("Control", "RNAse"),
       col = c("purple", "darkblue"), lwd = 2, cex = 0.6, inset = c(0, -0.05))  # kleiner und etwas weiter nach unten

# Index des aktuellen Proteins in den Tabellen finden
idx_ctrl <- which(abs_Maxima_Mittelwerte_Kontrolle[, 1] == zeile)
idx_rnase <- which(abs_Maxima_Mittelwerte_RNAse[, 1] == zeile)

# Maxima f√ºr Kontrolle aus Tabelle holen
max_fraktion_ctrl <- as.numeric(as.character(abs_Maxima_Mittelwerte_Kontrolle[idx_ctrl, 3]))
max_wert_ctrl <- as.numeric(as.character(abs_Maxima_Mittelwerte_Kontrolle[idx_ctrl, 4]))

# Maxima f√ºr RNAse aus Tabelle holen
max_fraktion_rnase <- as.numeric(as.character(abs_Maxima_Mittelwerte_RNAse[idx_rnase, 3]))
max_wert_rnase <- as.numeric(as.character(abs_Maxima_Mittelwerte_RNAse[idx_rnase, 4]))

# Vertikale Pfeile f√ºr die Maxima
arrows(x0 = max_fraktion_ctrl, y0 = 0,
       x1 = max_fraktion_ctrl, y1 = max_wert_ctrl,
       col = "purple", lwd = 1.5, length = 0.1)

arrows(x0 = max_fraktion_rnase, y0 = 0,
       x1 = max_fraktion_rnase, y1 = max_wert_rnase,
       col = "darkblue", lwd = 1.5, length = 0.1)

# Labels an den Maxima
text(x = max_fraktion_ctrl, y = max_wert_ctrl + 0.10 * max_wert_ctrl,
     labels = "Amplitude", col = "purple", cex = 0.8)

text(x = max_fraktion_rnase, y = max_wert_rnase + 0.05 * max_wert_rnase,
     labels = "Amplitude", col = "darkblue", cex = 0.8)

# Shift-Distance-Pfeil zwischen den Maxima (auf kleinstem Maxima-Niveau)
arrow_y <- min(max_wert_ctrl, max_wert_rnase)

arrows(x0 = max_fraktion_ctrl, y0 = arrow_y,
       x1 = max_fraktion_rnase, y1 = arrow_y,
       col = "black", lwd = 1.6, angle = 15, length = 0.1, code = 3)  # code=3 = beide Enden

# Label f√ºr den Shift
text(x = mean(c(max_fraktion_ctrl, max_fraktion_rnase)),
     y = arrow_y + 0.05 * arrow_y,
     labels = "Shift Distance", col = "black", cex = 0.8)

```

```{r}
library(dplyr)
library(ggplot2)

# RBP-Status zuordnen
df_ergebnisse_phys <- df_ergebnisse_phys %>%
  mutate(RBP_Gruppe = ifelse(Shift_Kategorie == "kein_shift", "non-RBP", "RBP"))

# Summen berechnen pro RBP_Gruppe + Shift_Kategorie
df_summary <- df_ergebnisse_phys %>%
  group_by(RBP_Gruppe, Shift_Kategorie) %>%
  summarise(n = n(), .groups = "drop") %>%
  mutate(
    # Kategorie-Label mit Anzahl f√ºr die Legende
    Kategorie_mit_n = paste0(Shift_Kategorie, " (", n, ")")
  )

ggplot(df_summary, aes(x = RBP_Gruppe, y = n, fill = Kategorie_mit_n)) +
  geom_col(position = "stack") +
  # Kein geom_text() ‚Üí keine Zahlen in den Balken
  scale_fill_manual(
    values = setNames(
      c("#A786C2", "#8684C2", "#7396AD", "#728083","#DBCEE6"), 
      df_summary$Kategorie_mit_n
    )
  ) +
  labs(title = "Total Amount of Proteins per Shift category",
       x = "Protein Type", y = "Total Amount of Proteins", fill = "Shift-Kategorie (n)") +
  theme_minimal(base_size = 13)

```


```{r}
library(dplyr)

abs_Maxima_Mittelwerte_Kontrolle <- Maxima_Mittelwerte_Kontrolle %>%
  group_by(Protein) %>%                   # Gruppieren nach Protein
  slice_max(order_by = Wert, n = 1) %>% # Zeile mit maximalem Maxima behalten
  ungroup()

abs_Maxima_Mittelwerte_RNAse <- Maxima_Mittelwerte_RNAse %>%
  group_by(Protein) %>%                   # Gruppieren nach Protein
  slice_max(order_by = Wert, n = 1) %>% # Zeile mit maximalem Maxima behalten
  ungroup()
```

```{r}
merged <- merge(
  abs_Maxima_Mittelwerte_Kontrolle[, c("Protein", "Fraktion")],
  abs_Maxima_Mittelwerte_RNAse[, c("Protein", "Fraktion")],
  by = "Protein",
  suffixes = c("_control", "_rnase")
)

# Berechnung der Anzahl der Punkte √ºber, auf und unter der Linie y = x
above_line <- sum(merged$Fraktion_control > merged$Fraktion_rnase)
on_line <- sum(merged$Fraktion_control == merged$Fraktion_rnase)
below_line <- sum(merged$Fraktion_control < merged$Fraktion_rnase)

# Ausgabe der Werte in der Konsole
cat("Anzahl Proteine √ºber der Linie:", above_line, "\n")
cat("Anzahl Proteine auf der Linie:", on_line, "\n")
cat("Anzahl Proteine unter der Linie:", below_line, "\n")

# Plot nochmal, damit Text eingef√ºgt wird
plot(
  y = merged$Fraktion_control,
  x = merged$Fraktion_rnase,
  xlim = c(0, 25),
  ylim = c(0, 25),
  ylab = "Peaks in the control gradient (Fraction)",
  xlab = "Peaks in the RNase gradient (Fraction)",
  pch = 16, col = rgb(0,0,0,0.5),
  main = "Maxima-Shift der Proteine"
)
abline(0, 1, col = "blue", lty = 2)

# Text mit den Zahlen links unten hinzuf√ºgen
text(x = 19, y = 2,
     labels = paste0(
       "left_Shift: ", above_line, "\n",
       "kein_Shift: ", on_line, "\n",
       "right_Shift: ", below_line),
     adj = 0, cex = 0.8, col = "black")

```

#Data_Modelling
```{r}
hist(df_ergebnisse$Shift_Score,
     breaks = 30,
     col = "skyblue",
     main = "Distribution of the Shift Scores",
     xlab = "Shift Score")
```



# App f√ºr die Manuelle Bestimmung

```{#r}
library(shiny)

# üì• Daten laden
if (file.exists("df_ergebnisse_mit_bewertung.RData")) {
  load("df_ergebnisse_mit_bewertung.RData")
} else if (file.exists("df_ergebnisse_original.RData")) {
  load("df_ergebnisse_original.RData")
} else {
  stop("‚ùå Keine Daten gefunden: Bitte stelle sicher, dass df_ergebnisse vorhanden ist.")
}

# Spalten f√ºr Bewertung & Anmerkung hinzuf√ºgen, falls noch nicht vorhanden
if (!"Manuelle_Bewertung" %in% colnames(df_ergebnisse)) {
  df_ergebnisse$Manuelle_Bewertung <- NA_character_
}
if (!"Anmerkung" %in% colnames(df_ergebnisse)) {
  df_ergebnisse$Anmerkung <- NA_character_
}

# üü° Start bei erstem unbewertetem Protein
start_index <- which(is.na(df_ergebnisse$Manuelle_Bewertung))[1]
if (is.na(start_index)) start_index <- 1

ui <- fluidPage(
  titlePanel("üî¨ Manuelle Protein-Bewertung"),
  sidebarLayout(
    sidebarPanel(
      textInput("start_protein_input", "Protein (Name):", value = df_ergebnisse$Protein[start_index]),
      actionButton("go_start", "Suchen"),
      br(), br(),
      actionButton("btn_prev", "‚Üê Vorheriges Protein"),
      actionButton("btn_next", "N√§chstes Protein ‚Üí"),
      br(), br(),
      strong(textOutput("protein_position")),  # Anzeige "Protein X von Y"
      strong("Aktuelles Protein:"),
      textOutput("protein_name"),
      br(),
      radioButtons("bewertung", "Kategorie ausw√§hlen:",
                   choices = c("kein_shift", "moderater_right_shift", "starker_right_shift",
                               "moderater_left_shift", "starker_left_shift"),
                   selected = character(0)),
      textAreaInput("anmerkung", "Anmerkung (optional):", "", rows = 3),
      actionButton("save", "üíæ Bewertung speichern"),
      br(), br(),
      strong("Automatische Kategorie:"),
      textOutput("auto_kat"),
      br(),
      actionButton("exit", "‚ùå App beenden", class = "btn-danger"),
      br(),
      textOutput("save_status")
    ),
    mainPanel(
      plotOutput("plot", height = "400px")
    )
  )
)

server <- function(input, output, session) {
  current <- reactiveVal(start_index)
  save_status <- reactiveVal("")

  # Springe zum Protein, wenn "go_start" gedr√ºckt wird
  observeEvent(input$go_start, {
    protein_name <- input$start_protein_input
    idx <- which(df_ergebnisse$Protein == protein_name)
    if (length(idx) == 1) {
      current(idx)
      save_status("")
    } else {
      showModal(modalDialog(
        title = "‚ö†Ô∏è Protein nicht gefunden",
        paste0("Protein '", protein_name, "' nicht gefunden. Bitte genau so eingeben wie in der Tabelle."),
        easyClose = TRUE
      ))
    }
  })

  # Eingabefelder aktualisieren, wenn sich aktuelles Protein √§ndert
  observeEvent(current(), {
    idx <- current()
    updateRadioButtons(session, "bewertung",
                       selected = df_ergebnisse$Manuelle_Bewertung[idx])
    updateTextAreaInput(session, "anmerkung",
                        value = df_ergebnisse$Anmerkung[idx])
    updateTextInput(session, "start_protein_input",
                    value = df_ergebnisse$Protein[idx])
    save_status("")
  })

  observeEvent(input$btn_prev, {
    idx <- current()
    if (idx > 1) current(idx - 1)
  })

  observeEvent(input$btn_next, {
    idx <- current()
    if (idx < nrow(df_ergebnisse)) current(idx + 1)
  })

  output$protein_position <- renderText({
    paste0("Protein ", current(), " von ", nrow(df_ergebnisse))
  })

  output$protein_name <- renderText({
    df_ergebnisse$Protein[current()]
  })

  output$auto_kat <- renderText({
    df_ergebnisse$Shift_Kategorie[current()]
  })

  output$plot <- renderPlot({
    protein_id <- df_ergebnisse$Protein[current()]
    ctrl_vals <- as.numeric(Ctrl1_norm[protein_id, ])
    rnase_vals <- as.numeric(RNAse1_norm[protein_id, ])
    y_range <- range(c(ctrl_vals, rnase_vals), na.rm = TRUE)

    plot(1:length(ctrl_vals), ctrl_vals, type = "l", col = "purple", ylim = y_range,
         xlab = "Fraktion", ylab = "Intensit√§t", main = protein_id)
    lines(1:length(rnase_vals), rnase_vals, col = "darkblue")
    legend("topright", legend = c("Kontrolle", "RNase"), col = c("purple", "darkblue"), lty = 1)
  })

  observeEvent(input$save, {
    idx <- current()
    df_ergebnisse$Manuelle_Bewertung[idx] <<- input$bewertung
    df_ergebnisse$Anmerkung[idx] <<- input$anmerkung
    save(df_ergebnisse, file = "df_ergebnisse_mit_bewertung.RData")
    save_status("üíæ Bewertung gespeichert!")
    if (idx < nrow(df_ergebnisse)) {
      current(idx + 1)
    } else {
      showModal(modalDialog("üéâ Letztes Protein erreicht!", easyClose = TRUE))
    }
  })

  # Speichern beim Schlie√üen der Session (z.B. Browser schlie√üen)
  session$onSessionEnded(function() {
    save(df_ergebnisse, file = "df_ergebnisse_mit_bewertung.RData")
  })

  observeEvent(input$exit, {
    save(df_ergebnisse, file = "df_ergebnisse_mit_bewertung.RData")
    stopApp()
  })

  output$save_status <- renderText({
    save_status()
  })
}

shinyApp(ui, server)

```

