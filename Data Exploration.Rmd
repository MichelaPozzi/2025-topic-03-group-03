---
title: "Exploration"
output: html_document
date: "2025-05-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
MS_Table_norm = read.table("MS_Table.norm.csv", header=TRUE, row.names=1, sep = ",")
```

# Data exploration
```{r}
for (i in 1:6) {

  spalten_index = seq(from = i, to = 150, by = 6) 
  teilmatrix = MS_Table_norm[, spalten_index]
  
  assign(Treatmentnamen[i], teilmatrix) # neue Subtabellen, richtig benannt
}
```

```{r}
# absolute Maxima bestimmen: in welcher Fraktion und welcher Wert
for (i in 1:6) {
  Tabelle = get(Treatmentnamen[i])
  
  abs.Max = c(apply(Tabelle, 1, max)) # Maximum pro Protein
  Fraktion = c(apply(Tabelle, 1, which.max))
  
  teildata = cbind(Fraktion, abs.Max)
  
  assign(paste0('abs.Max_', Treatmentnamen[i]), teildata) # 6 Matritzen mit Maxima-Werten in zugehÃ¶riger Funktion
}

```

```{r}
plot(1:25, Ctrl1_norm[58,], type = "l", col = "blue",
     xlab = "Fraktion", ylab = "IntensitÃ¤t", main = "Proteinverteilung")


plot(1:25, RNAse1_norm[58,], type = "l", col = "blue",
     xlab = "Fraktion", ylab = "IntensitÃ¤t", main = "Proteinverteilung")

```


```{r}
find_maxima = function(mat) {
  result = do.call(rbind, lapply(1:nrow(mat), function(i) {
    x = mat[i, ]
    # Unterschiedliche Stellen
    idx = which(diff(sign(diff(x))) == -2) + 1 # Maxima
    
    # Maxima als Plateu
    
    
    # Randmaxima
    if (x[1] > x[2]) {idx = c(1, idx)} #Randmaxima bei 1
    if (x[25] > x[24]) {idx = c(idx, 25)} # Randmaxima bei 25

    
    # orte von gefundene Maxima werden der Tabelle angehangen
    if (length(idx) > 0) {
      data.frame(
        Zeile = i,
        Fraktion = idx,
        Wert = x[idx]
      )
    } else {
      NULL
    } 
  }))
  rownames(result) = NULL # damit die Namen nicht Ã¼berschreiben werden
  return(result)
  
}

mat = as.matrix(sapply(Ctrl1_norm, as.numeric))
Maxima_Ctrl_1 = find_maxima(mat)

```

## Maxima Bestimmung
BerÃ¼cksichtigt: Plateus, Randmaxima, Threshold

```{r}
# Funktion zum Finden der Maxima
find_maxima = function(mat, threshold = 2) {
  result = do.call(rbind, lapply(1:nrow(mat), function(i) {
    x = mat[i, ]
    
    # Normale Maxima (sign-change von + zu - => ergibt -2)
    idx = which(diff(sign(diff(x))) == -2) + 1 
    
    # Plateau-Maxima erkennen
    # Suche Bereiche, in denen Werte gleich sind und gleich oder grÃ¶ÃŸer als Nachbarn sind
    
    rle_x = rle(x)  # Run-Length-Encoding der Werte
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    plateau_idx = c()
    for (j in seq_along(values)) {
      # Nur Plateaus mit LÃ¤nge > 1 prÃ¼fen
      if (lengths[j] > 1) {
        start_pos = starts[j]
        end_pos = ends[j]
        
        # Werte links und rechts des Plateaus
        left_val = if (start_pos > 1) x[start_pos - 1] else -Inf
        right_val = if (end_pos < length(x)) x[end_pos + 1] else -Inf
        
        # Plateau ist lokales Maximum, wenn Wert >= Nachbarn
        if (values[j] >= left_val && values[j] >= right_val) {
          # Plateau-Maximum: Indize des Plateausstartpunkts
          plateau_idx = c(plateau_idx, start_pos)
        }
      }
    }
    
    # Kombination von normalen Maxima und Plateau-Maxima
    all_idx = sort(unique(c(idx, plateau_idx)))
    
    # Randmaxima (erste und letzte Position prÃ¼fen)
    if (x[1] > x[2]) {all_idx = c(1, all_idx)} #Randmaxima bei 1
    if (x[25] > x[24]) {all_idx = c(all_idx, 25)} # Randmaxima bei 25
    
    # nur Werte > threshold = 2% behalten
    all_idx = all_idx[x[all_idx] > threshold]
    
    # Ergebnis zusammenbauen
    if (length(all_idx) > 0) {
      data.frame(
        Zeile = i,
        Fraktion = all_idx,
        Wert = x[all_idx]
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}

Ctrl1_norm_mat = as.matrix(sapply(Ctrl1_norm, as.numeric))
Maxima_Ctrl_1 = find_maxima(Ctrl1_norm_mat)

RNAse1_norm_mat = as.matrix(sapply(RNAse1_norm, as.numeric))
Maxima_RNAse_1 = find_maxima(RNAse1_norm_mat)

```

```{r}
# Anwenden auf Tabellen 
# ?? Frage nur welche > Mittelwerte von RNAse & Controlle oder fÃ¼r alle 6 Substabellen; Maiwen hat fÃ¼r Mittel
mat = as.matrix(sapply(Ctrl1_norm, as.numeric))
Maxima_Ctrl_1 = find_maxima(mat)

```



## Schulterpunkte

```{r}
find_extrema = function(mat, threshold = 2, slope_threshold = NULL) {
  result = do.call(rbind, lapply(1:nrow(mat), function(i) {
    x = mat[i, ]
    
    # Normale Maxima (Knick in 1. Ableitung)
    idx = which(diff(sign(diff(x))) == -2) + 1 
    
    # Plateau-Maxima
    rle_x = rle(x)
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    plateau_idx = c()
    for (j in seq_along(values)) {
      if (lengths[j] > 1) {
        start_pos = starts[j]
        end_pos = ends[j]
        
        left_val = if (start_pos > 1) x[start_pos - 1] else -Inf
        right_val = if (end_pos < length(x)) x[end_pos + 1] else -Inf
        
        if (values[j] >= left_val && values[j] >= right_val) {
          plateau_idx = c(plateau_idx, start_pos:end_pos)
        }
      }
    }
    
    # Randmaxima prÃ¼fen
    max_idx = sort(unique(c(idx, plateau_idx)))
    if (x[1] > x[2]) {max_idx = c(1, max_idx)}
    if (x[length(x)] > x[length(x) - 1]) {max_idx = c(max_idx, length(x))}
    
    # Threshold filtern
    max_idx = max_idx[x[max_idx] > threshold]
    
    # Schulterpunkte erkennen
    dx = diff(x)
    shoulder_idx = c()
    for (j in 2:(length(dx)-1)) {
      # Steil ansteigend -> flach oder fallend
      if (!is.null(slope_threshold)) {
        if (dx[j-1] > slope_threshold && dx[j] < (0.5 * dx[j-1])) {
          shoulder_idx = c(shoulder_idx, j + 1)
        }
      } else {
        # Default ohne Schwellwert
        if (dx[j-1] > 1 && dx[j] < 0.5 * dx[j-1]) {
          shoulder_idx = c(shoulder_idx, j + 1)
        }
      }
    }
    
    # Maxima
    res_max = if (length(max_idx) > 0) {
      data.frame(
        Zeile = i,
        Position = max_idx,
        Wert = x[max_idx],
        Typ = "Maximum"
      )
    } else { NULL }
    
    # Schulterpunkte
    res_shoulder = if (length(shoulder_idx) > 0) {
      data.frame(
        Zeile = i,
        Position = shoulder_idx,
        Wert = x[shoulder_idx],
        Typ = "Schulter"
      )
    } else { NULL }
    
    rbind(res_max, res_shoulder)
  }))
  
  rownames(result) = NULL
  return(result)
}
mat = as.matrix(sapply(Ctrl1_norm, as.numeric))
Maxima_Schulter_Ctrl_1 = find_extrema(mat)

```


# Vergleich von RNAse & Kontrolle
```{r}

```





## Jettes Plan
- Funktionen erstellen fÃ¼r verschiedene anzahl an peaks (gucken, wie viele es generell gibt) mit Parametern Mittelwert, Standardabweichung, Amplitude, die Fehlerberechnung beinhalten und somit fÃ¼r jedes Protein fÃ¼r die jeweilige Verteilung optimiert werden kÃ¶nnen
- mit der optimierung fÃ¼r jedes Protein (noch bei den Mittelwerten der replikate) die passenden Parameter erhalten
- also optimierung fÃ¼r jeden der drei parameter und fÃ¼r jedes Treatment
- optimierte parameter abspeichern als vektor
- danach erst GauÃŸ fit fÃ¼r jedes Replikat durchfÃ¼hren

https://chatgpt.com/share/683b2417-6030-8006-b6d2-479f6f34f641

------------------------------------------------------------------------

### ğŸŸ© **Was im Protokoll gemacht wurde:**

1ï¸âƒ£ **Teil 2 (Peaks & Fit-Parameter)** Das GauÃŸ-Fitting in Teil 2 wurde auf den **gemittelten Profilen** (also dem Durchschnitt aus je drei Replikaten) gemacht:

-   **1 Mittelwert-Kurve** fÃ¼r Kontrolle (CTRL)
-   **1 Mittelwert-Kurve** fÃ¼r RNase

â¡ï¸ Ziel:

-   **robuste Erkennung von Maxima und Schultern**
-   â€globaleâ€œ Fit-Parameter (Amplitude, Lage, Breite) der **Durchschnittskurve** pro Protein und Bedingung
-   diese Maxima-Positionen dienen als â€Startpunkteâ€œ fÃ¼r die Fits in Teil 3

------------------------------------------------------------------------

2ï¸âƒ£ **Teil 3 (Gaussian Fit auf Einzeldaten)** Hier wurde das **GauÃŸ-Fitting fÃ¼r alle 6 Replikate einzeln** durchgefÃ¼hrt!

-   **3 Replikate fÃ¼r Kontrolle (ctrl1, ctrl2, ctrl3)**
-   **3 Replikate fÃ¼r RNase (rnase1, rnase2, rnase3)**

â¡ï¸ Ziel:

-   **individuelle Fit-Parameter** pro Replikat (z.B. Amplitude = Proteinmenge in diesem Peak in diesem Replikat!)
-   diese Werte werden spÃ¤ter (Teil 5) mit einem **t-Test** zwischen den Bedingungen (CTRL vs. RNase) verglichen.

------------------------------------------------------------------------

### ğŸŸ¡ **Zusammengefasst:**

| Phase | Datenbasis | Ziel |
|---------------|------------------|---------------------------------------|
| **Teil 2** | Mittelwert-Kurve aus 3 Replikaten | Finden von Peaks und deren Startparameter (robust, stabil) |
| **Teil 3** | 6 Replikat-Kurven (je Protein) | Fit-Parameter (Amplitude, Position, Breite) pro Replikat ermitteln |

------------------------------------------------------------------------

âœ… **Also: Das finale GauÃŸ-Fitting fÃ¼r die t-Tests wird an allen 6 Replikaten gemacht!** âŒ **Nicht nur auf den Mittelwerten!** âœ… Aber die Mittelwert-Kurve liefert die â€guten Startwerteâ€œ, damit die Fits bei den Einzel-Replikaten stabiler sind.

------------------------------------------------------------------------

ğŸ’¡ **Falls du mÃ¶chtest**, kann ich dir das gerne auch als â€Schemaâ€œ zeichnen (z.B. Flowchart), wie das Protokoll hier ablÃ¤uft! ğŸš€
