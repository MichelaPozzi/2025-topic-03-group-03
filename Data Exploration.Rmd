---
title: "Exploration"
output: html_document
date: "2025-05-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
MS_Table_norm = read.table("MS_Table.norm.csv", header=TRUE, row.names=1, sep = ",")
```

# Data exploration

```{r}
Fraktionsnamen = c('Fraction1_Ctrl', 'Fraction1_RNAse', 'Fraction2_Ctrl', 'Fraction2_RNAse','Fraction3_Ctrl', 'Fraction3_RNAse','Fraction4_Ctrl', 'Fraction4_RNAse','Fraction5_Ctrl', 'Fraction5_RNAse','Fraction6_Ctrl', 'Fraction6_RNAse','Fraction7_Ctrl', 'Fraction7_RNAse','Fraction8_Ctrl', 'Fraction8_RNAse','Fraction9_Ctrl', 'Fraction9_RNAse','Fraction10_Ctrl', 'Fraction10_RNAse','Fraction11_Ctrl', 'Fraction11_RNAse','Fraction12_Ctrl', 'Fraction12_RNAse','Fraction13_Ctrl', 'Fraction13_RNAse','Fraction14_Ctrl', 'Fraction14_RNAse','Fraction15_Ctrl', 'Fraction15_RNAse','Fraction16_Ctrl', 'Fraction16_RNAse','Fraction17_Ctrl', 'Fraction17_RNAse','Fraction18_Ctrl', 'Fraction18_RNAse','Fraction19_Ctrl', 'Fraction19_RNAse','Fraction20_Ctrl', 'Fraction20_RNAse','Fraction21_Ctrl', 'Fraction21_RNAse','Fraction22_Ctrl', 'Fraction22_RNAse','Fraction23_Ctrl', 'Fraction23_RNAse','Fraction24_Ctrl', 'Fraction24_RNAse','Fraction25_Ctrl', 'Fraction25_RNAse')
```

```{r}
Proteinnamen = rownames(MS_Table)
```



```{r} 
# Subtabellen für jedes Replikat
for (i in 1:6) {

  spalten_index = seq(from = i, to = 150, by = 6) 
  teilmatrix = MS_Table_norm[, spalten_index]
  
  assign(Treatmentnamen[i], teilmatrix) # neue Subtabellen, richtig benannt
}
```

```{r}
# Mittelwerte für Treatments als Tabelle

Mittelwert_matrix = t(apply(MS_Table_norm, 1, function(row) {
  sapply(1:50, function(i) {
    spalten_index = ((i - 1) * 3 + 1):(i * 3)
    mean(row[spalten_index])
  })
}))

# Jeden zweiten Mittelwert auswählen
Mittelwerte_Kontrolle = as.data.frame(Mittelwert_matrix[, seq(1, 50, by=2)])
Mittelwerte_RNAse = as.data.frame(Mittelwert_matrix[, seq(2, 50, by=2)])

colnames(Mittelwerte_Kontrolle) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
colnames(Mittelwerte_RNAse) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
  
```


## Maxima Bestimmung
Berücksichtigt: Plateaus, gespaltene Peaks, Randmaxima, Threshold

```{r}
find_maxima = function(mat, threshold = 2) {
  result = do.call(rbind, lapply(1:nrow(mat), function(i) {
    x = mat[i, ]
    
    # Normale Maxima: zweite Ableitung mit Vorzeichenwechsel
    idx = which(diff(sign(diff(x))) == -2) + 1 
    
    # Plateaumaxima
    rle_x = rle(x)  # Run-Length-Encoding der Werte
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    plateau_idx = c()
    for (j in seq_along(values)) {
      # Nur Plateaus mit Länge > 1 prüfen
      if (lengths[j] > 1) {
        start_pos = starts[j]
        end_pos = ends[j]
        
        # Werte links und rechts des Plateaus
        left_val = if (start_pos > 1) x[start_pos - 1] else -Inf
        right_val = if (end_pos < length(x)) x[end_pos + 1] else -Inf
        
        # Plateau ist lokales Maximum, wenn Wert >= Nachbarn
        if (values[j] >= left_val && values[j] >= right_val) {
          # Plateau-Maximum: Indize des Plateausstartpunkts
          plateau_idx = c(plateau_idx, mean(start_pos:end_pos))
        }
      }
    }
    
    # Kombination von normalen Maxima und Plateau-Maxima
    all_idx = sort(unique(c(idx, plateau_idx))) #unique: falls Werte doppelt werden sie entfernt, sort: sotieren der Indizes in aufsteigender Reihenfolge
    
    # Randmaxima prüfen
    if (x[1] > x[2]) {all_idx = c(1, all_idx)}
    if (x[length(x)] > x[length(x)-1]) {all_idx = c(all_idx, length(x))}
    
    # nur Werte > threshold = 2% behalten
    all_idx = all_idx[x[all_idx] > threshold]
    
    # Peaks bereinigen: Wenn zwei Peaks nur einen Wert dazwischen haben, den kleineren entfernen
    if (length(all_idx) >= 2) {
      to_remove = c()
      for (k in 1:(length(all_idx)-1)) {
        if (all_idx[k+1] - all_idx[k] == 2) {
          # Indizes der Peaks
          peak1 = all_idx[k]
          peak2 = all_idx[k+1]
          if (x[peak1] >= x[peak2]) {
            to_remove = c(to_remove, peak2)
          } else {
            to_remove = c(to_remove, peak1)
          }
        }
      } # Entfernen des niedrigeren Wert
      if (length(to_remove) > 0) {
        all_idx = setdiff(all_idx, to_remove)
      }
    }
    
    if (length(all_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = all_idx,
        Wert = x[all_idx]
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}

# Maxima für Mittelwerte aus Triplikaten
Mittelwerte_Kontrolle_mat = as.matrix(sapply(Mittelwerte_Kontrolle, as.numeric))
Mittelwerte_RNAse_mat = as.matrix(sapply(Mittelwerte_RNAse, as.numeric))

Maxima_Mittelwerte_Kontrolle = find_maxima(Mittelwerte_Kontrolle_mat)
Maxima_Mittelwerte_RNAse = find_maxima(Mittelwerte_RNAse_mat)
```

## Schulterpunkte

```{r}
# Funktion zum Finden der Schulterpunkte
find_shoulders = function(binary_mat, Proteinnamen) {
  result = do.call(rbind, lapply(1:nrow(binary_mat), function(i) {
    x = binary_mat[i, ]
    rle_x = rle(x)
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    schulter_idx = c()
    for (j in seq_along(values)) {
      if (values[j] == 1 && lengths[j] >= 4) {
        start_pos = starts[j]
        end_pos = ends[j]
        schulter_idx = c(schulter_idx, mean(start_pos:end_pos))
      }
    }
    
    if (length(schulter_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = schulter_idx
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}
```


### Schulterpunkte für Kontrolle
```{r} 
#vorübergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_Kontrolle = ifelse(Mittelwerte_Kontrolle > 2, 1, 0) # wenn größer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vorübergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife über alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_Kontrolle)) {
  Protein = Maxima_Mittelwerte_Kontrolle$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_Kontrolle$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen für die Spalten berechnen (Grenzen prüfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_Kontrolle), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_Kontrolle[Protein, Fraktions_bereich] = 0
}

Schulterpunkte_Kontrolle = find_shoulders(Schulter_Mittelwerte_Kontrolle, Proteinnamen)

```

### Schulterpunkte für RNAse

```{r}
#vorübergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_RNAse = ifelse(Mittelwerte_RNAse > 2, 1, 0) # wenn größer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vorübergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife über alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_RNAse)) {
  Protein = Maxima_Mittelwerte_RNAse$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_RNAse$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen für die Spalten berechnen (Grenzen prüfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_RNAse), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_RNAse[Protein, Fraktions_bereich] = 0
}


Schulterpunkte_RNAse = find_shoulders(Schulter_Mittelwerte_RNAse, Proteinnamen)
```

# es gibt nicht viele Schulterpunkte bei 2,5 die frage ist nur ob wir die entfernen müssen

## Zusammenführen der Werte
Ich würde das nochmal bisschen verändern aber so funktioniert es auf jeden Fall und wir haben Tabellen in denen jetzt alle Maxima & Schulerpunkte haben zum Weiterarbeiten

```{r}
# Für Schulterpunkte Wert hinzufügen
Schulterpunkte_Kontrolle$Fraktion_gerundet = round(Schulterpunkte_Kontrolle$Fraktion)
Schulterpunkte_Kontrolle$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_Kontrolle[zeile, fraktion]
}, Schulterpunkte_Kontrolle$Zeile, Schulterpunkte_Kontrolle$Fraktion_gerundet)

Schulterpunkte_RNAse$Fraktion_gerundet = round(Schulterpunkte_RNAse$Fraktion)
Schulterpunkte_RNAse$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_RNAse[zeile, fraktion]
}, Schulterpunkte_RNAse$Zeile, Schulterpunkte_RNAse$Fraktion_gerundet)

# Markieren und zusammenfügen Kontrolle
Maxima_Mittelwerte_Kontrolle$Typ = "Maxima"
Schulterpunkte_Kontrolle$Typ = "Schulter"

Combined_Kontrolle = rbind(
  Maxima_Mittelwerte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_Kontrolle = Combined_Kontrolle[order(Combined_Kontrolle$Zeile, Combined_Kontrolle$Fraktion), ]

# Markieren und zusammenfügen RNAse
Maxima_Mittelwerte_RNAse$Typ = "Maxima"
Schulterpunkte_RNAse$Typ = "Schulter"

Combined_RNAse = rbind(
  Maxima_Mittelwerte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_RNAse = Combined_RNAse[order(Combined_RNAse$Zeile, Combined_RNAse$Fraktion), ]
```



# Vergleich von RNAse & Kontrolle
```{r}
# P-Werte bestimmen für die verschiedenen Maxima
# Spaltennamen dedr Subtabellen nue benennen, um darauf zugreifen zu können über Combined_Kontrolle und Combined_RNAse
Ctrl1_frakt = Ctrl1_norm
colnames(Ctrl1_frakt) = c(1:25)
Ctrl2_frakt = Ctrl2_norm
colnames(Ctrl2_frakt) = c(1:25)
Ctrl3_frakt = Ctrl3_norm
colnames(Ctrl3_frakt) = c(1:25)

RNAse1_frakt = RNAse1_norm
colnames (RNAse1_frakt) = c(1:25)
RNAse2_frakt = RNAse2_norm
colnames(RNAse2_frakt) = c(1:25)
RNAse3_frakt = RNAse3_norm
colnames(RNAse3_frakt) = c(1:25)

# Listen bilden aus den Replikaten von Kontrolle und RNAse
ctrl_reps = list(Ctrl1_frakt, Ctrl2_frakt, Ctrl3_frakt)
rnase_reps = list(RNAse1_frakt, RNAse2_frakt, RNAse3_frakt)

# Datframe von Kontrolle und RNAse mit nur den Positionen der Peaks
peaks_ctrl = data.frame(Protein = Combined_Kontrolle$Protein, Fraktion = Combined_Kontrolle$Fraktion, Treatment = 'Kontrolle')
peaks_rnase = data.frame(Protein = Combined_RNAse$Protein, Fraktion = Combined_RNAse$Fraktion, Treatment = 'RNase')


# Gemeinsame Protein-Fraktion-Kombinationen von Kontrolle und RNAse bestimmen
shared_peaks = merge(peaks_ctrl, peaks_rnase, by = c("Protein", "Fraktion"))

# Dataframe für die Ergebnisse aufstellen
p_Werte = data.frame()

for (i in 1:nrow(shared_peaks)) {
  protein  = shared_peaks$Protein[i]
  fraktion = as.character(shared_peaks$Fraktion[i])
  
  # Kontrollwerte extrahieren: über Position in shared peaks
  ctrl_vals = sapply(ctrl_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })

  # RNase-Werte extrahieren: über Position in shared peaks
  rnase_vals = sapply(rnase_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })
   # NA Werte entfernen
  ctrl_vals = na.omit(ctrl_vals)
  rnase_vals = na.omit(rnase_vals)

  # Wenn nötig: Mini-Störung hinzufügen bei identischen Werten
  if (length(ctrl_vals) >= 2 && all(abs(ctrl_vals - ctrl_vals[1]) < 1e-10)) {
    ctrl_vals[2] <- ctrl_vals[2] + 1e-6
  }
  if (length(rnase_vals) >= 2 && all(abs(rnase_vals - rnase_vals[1]) < 1e-10)) {
    rnase_vals[2] <- rnase_vals[2] + 1e-6
  }

  # t-Test nur wenn beide Gruppen mindestens 2 Werte haben
  # Varianztest mit F-Test, um zu gucken, ob Kontrolle und RNAse gleiche Varianz haben: wichtig für t-Test Durchführung

  if (length(ctrl_vals) >= 2 && length(rnase_vals) >= 2) {
    ftest_p = tryCatch(var.test(ctrl_vals, rnase_vals)$p.value, error = function(e) NA) # nur auf den p.value zugreifen im F-Test
    t_p = tryCatch(
      t.test(ctrl_vals, rnase_vals, var.equal = (ftest_p > 0.05))$p.value, # mögliche Fehler mit tryCatch abfangen
      error = function(e) NA
    )
  } 
  p_Werte = rbind(p_Werte, data.frame(Protein = protein, Fraktion = fraktion, P_Value = t_p))
}


# FDR-Korrektur
p_Werte$adj_p = p.adjust(p_Werte$P_Value, method = "BH")

```

```{r}
# Funktion mit allen relevanten paramtern erstellen, die für jedes Protein bestimmt werden
#maxima werte (amplitude) -> threshold für relevantes maximum festlegen
#differenz der amplituden -> gain (rnase) oder loss (Kontrolle)?
#proteinmenge (area under the curve) -
#unterschied in position der maxima - Abstand
#p werte dazu schreiben
liste_maxima_Ctrl = split(Combined_Kontrolle[, c("Fraktion", "Wert")], Combined_Kontrolle$Protein)
liste_maxima_RNAse = split(Combined_RNAse[, c("Fraktion", "Wert")], Combined_RNAse$Protein)


hol_shifts = function(Protein) { 
  shift = numeric(0)
  
  # maxima holen
  ctrl_maxima = liste_maxima_Ctrl[[Protein]]
  rnase_maxima = liste_maxima_RNAse[[Protein]]
  
  if (is.null(ctrl_maxima)) ctrl_maxima = data.frame(Fraktion = numeric(0), Wert = numeric(0))
  if (is.null(rnase_maxima)) rnase_maxima = data.frame(Fraktion = numeric(0), Wert = numeric(0))
  
  nb_ctrl_maxima = nrow(ctrl_maxima)
  nb_rnase_maxima = nrow(rnase_maxima)
  
  #Abstände aller Maxima zueinander zwischen Kontrolle und RNAse berechnen
  abstände = c()
  for (i in 1: nb_ctrl_maxima) {
    abstände = c(abstände,liste_maxima_RNAse$Fraktion[i]-liste_maxima_Ctrl$Fraktion)
  }
  abstände = unlist(abstände)
  
  # Differenz der Amplituden
   if (is.null(ctrl_maxima)) ctrl_maxima = data.frame(Fraktion = numeric(0), Wert = numeric(0))
   if (is.null(rnase_maxima)) rnase_maxima = data.frame(Fraktion = numeric(0), Wert = numeric(0))

  # Loss: Kontroll-Maxima -> RNase
  loss_list = c()
  for (i in 1:nb_ctrl_maxima) {
    fraktion_i = ctrl_maxima$Fraktion[i]
    amp_ctrl = ctrl_maxima$Wert[i]

    amp_rnase = Combined_RNAse$Wert[Combined_RNAse$Protein == Protein & Combined_RNAse$Fraktion == fraktion_i]
    if (length(amp_rnase) == 0) amp_rnase = 0

    loss_list = c(loss_list, amp_ctrl - amp_rnase)
  } 
  # Gain: RNAse-Maxima -> Kontrolle
  gain_list = c()
  for (i in 1:nb_rnase_maxima) {
    fraktion_i = rnase_maxima$Fraktion[i]
    amp_rnase = rnase_maxima$Wert[i]

    amp_ctrl = Combined_Kontrolle$Wert[Combined_Kontrolle$Protein == Protein & Combined_Kontrolle$Fraktion == fraktion_i]
    if (length(amp_ctrl) == 0) amp_ctrl = 0

    gain_list = c(gain_list, amp_rnase - amp_ctrl)
  }
  # Proteinmenge berechnen
  return(list(
    Protein = Protein,
    Anzahl_Kontroll_Maxima = nb_ctrl_maxima,
    Anzahl_RNase_Maxima = nb_rnase_maxima,
    Abstände_Maxima = abstände,
    Verlust_Amplituden = loss_list,
    Gewinn_Amplituden = gain_list,
    Summierter_Verlust = sum(loss_list),
    Summierter_Gewinn = sum(gain_list)
  ))
}



hol_shifts('1433B_HUMAN')
```


```{r}
plot(1:25, Ctrl1_norm['41_HUMAN',], type = "l", col = "blue",
     xlab = "Fraktion", ylab = "Intensität", main = "Proteinverteilung")


 plot(1:25, RNAse1_norm['41_HUMAN',], type = "l", col = "blue",
    xlab = "Fraktion", ylab = "Intensität", main = "Proteinverteilung")

```




















## Jettes Plan
- Funktionen erstellen für verschiedene anzahl an peaks (gucken, wie viele es generell gibt) mit Parametern Mittelwert, Standardabweichung, Amplitude, die Fehlerberechnung beinhalten und somit für jedes Protein für die jeweilige Verteilung optimiert werden können
- mit der optimierung für jedes Protein (noch bei den Mittelwerten der replikate) die passenden Parameter erhalten
- also optimierung für jeden der drei parameter und für jedes Treatment
- optimierte parameter abspeichern als vektor
- danach erst Gauß fit für jedes Replikat durchführen

https://chatgpt.com/share/683b2417-6030-8006-b6d2-479f6f34f641

------------------------------------------------------------------------

### 🟩 **Was im Protokoll gemacht wurde:**

1️⃣ **Teil 2 (Peaks & Fit-Parameter)** Das Gauß-Fitting in Teil 2 wurde auf den **gemittelten Profilen** (also dem Durchschnitt aus je drei Replikaten) gemacht:

-   **1 Mittelwert-Kurve** für Kontrolle (CTRL)
-   **1 Mittelwert-Kurve** für RNase

➡️ Ziel:

-   **robuste Erkennung von Maxima und Schultern**
-   „globale“ Fit-Parameter (Amplitude, Lage, Breite) der **Durchschnittskurve** pro Protein und Bedingung
-   diese Maxima-Positionen dienen als „Startpunkte“ für die Fits in Teil 3

------------------------------------------------------------------------

2️⃣ **Teil 3 (Gaussian Fit auf Einzeldaten)** Hier wurde das **Gauß-Fitting für alle 6 Replikate einzeln** durchgeführt!

-   **3 Replikate für Kontrolle (ctrl1, ctrl2, ctrl3)**
-   **3 Replikate für RNase (rnase1, rnase2, rnase3)**

➡️ Ziel:

-   **individuelle Fit-Parameter** pro Replikat (z.B. Amplitude = Proteinmenge in diesem Peak in diesem Replikat!)
-   diese Werte werden später (Teil 5) mit einem **t-Test** zwischen den Bedingungen (CTRL vs. RNase) verglichen.

------------------------------------------------------------------------

### 🟡 **Zusammengefasst:**

| Phase | Datenbasis | Ziel |
|---------------|------------------|---------------------------------------|
| **Teil 2** | Mittelwert-Kurve aus 3 Replikaten | Finden von Peaks und deren Startparameter (robust, stabil) |
| **Teil 3** | 6 Replikat-Kurven (je Protein) | Fit-Parameter (Amplitude, Position, Breite) pro Replikat ermitteln |

------------------------------------------------------------------------

✅ **Also: Das finale Gauß-Fitting für die t-Tests wird an allen 6 Replikaten gemacht!** ❌ **Nicht nur auf den Mittelwerten!** ✅ Aber die Mittelwert-Kurve liefert die „guten Startwerte“, damit die Fits bei den Einzel-Replikaten stabiler sind.

------------------------------------------------------------------------

💡 **Falls du möchtest**, kann ich dir das gerne auch als „Schema“ zeichnen (z.B. Flowchart), wie das Protokoll hier abläuft! 🚀
