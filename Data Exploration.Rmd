---
title: "Exploration"
output: html_document
date: "2025-05-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
MS_Table_norm = read.table("MS_Table.norm.csv", header=TRUE, row.names=1, sep = ",")
```

# Data exploration

```{r}
Fraktionsnamen = c('Fraction1_Ctrl', 'Fraction1_RNAse', 'Fraction2_Ctrl', 'Fraction2_RNAse','Fraction3_Ctrl', 'Fraction3_RNAse','Fraction4_Ctrl', 'Fraction4_RNAse','Fraction5_Ctrl', 'Fraction5_RNAse','Fraction6_Ctrl', 'Fraction6_RNAse','Fraction7_Ctrl', 'Fraction7_RNAse','Fraction8_Ctrl', 'Fraction8_RNAse','Fraction9_Ctrl', 'Fraction9_RNAse','Fraction10_Ctrl', 'Fraction10_RNAse','Fraction11_Ctrl', 'Fraction11_RNAse','Fraction12_Ctrl', 'Fraction12_RNAse','Fraction13_Ctrl', 'Fraction13_RNAse','Fraction14_Ctrl', 'Fraction14_RNAse','Fraction15_Ctrl', 'Fraction15_RNAse','Fraction16_Ctrl', 'Fraction16_RNAse','Fraction17_Ctrl', 'Fraction17_RNAse','Fraction18_Ctrl', 'Fraction18_RNAse','Fraction19_Ctrl', 'Fraction19_RNAse','Fraction20_Ctrl', 'Fraction20_RNAse','Fraction21_Ctrl', 'Fraction21_RNAse','Fraction22_Ctrl', 'Fraction22_RNAse','Fraction23_Ctrl', 'Fraction23_RNAse','Fraction24_Ctrl', 'Fraction24_RNAse','Fraction25_Ctrl', 'Fraction25_RNAse')
```

```{r}
Proteinnamen = rownames(MS_Table)
```



```{r} 
# Subtabellen für jedes Replikat
for (i in 1:6) {

  spalten_index = seq(from = i, to = 150, by = 6) 
  teilmatrix = MS_Table_norm[, spalten_index]
  
  assign(Treatmentnamen[i], teilmatrix) # neue Subtabellen, richtig benannt
}
```

```{r}
# Mittelwerte für Treatments als Tabelle

Mittelwert_matrix = t(apply(MS_Table_norm, 1, function(row) {
  sapply(1:50, function(i) {
    spalten_index = ((i - 1) * 3 + 1):(i * 3)
    mean(row[spalten_index])
  })
}))

# Jeden zweiten Mittelwert auswählen
Mittelwerte_Kontrolle = as.data.frame(Mittelwert_matrix[, seq(1, 50, by=2)])
Mittelwerte_RNAse = as.data.frame(Mittelwert_matrix[, seq(2, 50, by=2)])

colnames(Mittelwerte_Kontrolle) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
colnames(Mittelwerte_RNAse) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
  
```


## Maxima Bestimmung
Berücksichtigt: Plateaus, gespaltene Peaks, Randmaxima, Threshold

```{r}
find_maxima = function(mat, threshold = 2) {
  result = do.call(rbind, lapply(1:nrow(mat), function(i) {
    x = mat[i, ]
    
    # Normale Maxima: zweite Ableitung mit Vorzeichenwechsel
    idx = which(diff(sign(diff(x))) == -2) + 1 
    
    # Plateaumaxima
    rle_x = rle(x)  # Run-Length-Encoding der Werte
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    plateau_idx = c()
    for (j in seq_along(values)) {
      # Nur Plateaus mit Länge > 1 prüfen
      if (lengths[j] > 1) {
        start_pos = starts[j]
        end_pos = ends[j]
        
        # Werte links und rechts des Plateaus
        left_val = if (start_pos > 1) x[start_pos - 1] else -Inf
        right_val = if (end_pos < length(x)) x[end_pos + 1] else -Inf
        
        # Plateau ist lokales Maximum, wenn Wert >= Nachbarn
        if (values[j] >= left_val && values[j] >= right_val) {
          # Plateau-Maximum: Indize des Plateausstartpunkts
          plateau_idx = c(plateau_idx, mean(start_pos:end_pos))
        }
      }
    }
    
    # Kombination von normalen Maxima und Plateau-Maxima
    all_idx = sort(unique(c(idx, plateau_idx))) #unique: falls Werte doppelt werden sie entfernt, sort: sotieren der Indizes in aufsteigender Reihenfolge
    
    # Randmaxima prüfen
    if (x[1] > x[2]) {all_idx = c(1, all_idx)}
    if (x[length(x)] > x[length(x)-1]) {all_idx = c(all_idx, length(x))}
    
    # nur Werte > threshold = 2% behalten
    all_idx = all_idx[x[all_idx] > threshold]
    
    # Peaks bereinigen: Wenn zwei Peaks nur einen Wert dazwischen haben, den kleineren entfernen
    if (length(all_idx) >= 2) {
      to_remove = c()
      for (k in 1:(length(all_idx)-1)) {
        if (all_idx[k+1] - all_idx[k] == 2) {
          # Indizes der Peaks
          peak1 = all_idx[k]
          peak2 = all_idx[k+1]
          if (x[peak1] >= x[peak2]) {
            to_remove = c(to_remove, peak2)
          } else {
            to_remove = c(to_remove, peak1)
          }
        }
      } # Entfernen des niedrigeren Wert
      if (length(to_remove) > 0) {
        all_idx = setdiff(all_idx, to_remove)
      }
    }
    
    if (length(all_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = all_idx,
        Wert = x[all_idx]
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}

# Maxima für Mittelwerte aus Triplikaten
Mittelwerte_Kontrolle_mat = as.matrix(sapply(Mittelwerte_Kontrolle, as.numeric))
Mittelwerte_RNAse_mat = as.matrix(sapply(Mittelwerte_RNAse, as.numeric))

Maxima_Mittelwerte_Kontrolle = find_maxima(Mittelwerte_Kontrolle_mat)
Maxima_Mittelwerte_RNAse = find_maxima(Mittelwerte_RNAse_mat)
```

## Schulterpunkte

```{r}
# Funktion zum Finden der Schulterpunkte
find_shoulders = function(binary_mat, Proteinnamen) {
  result = do.call(rbind, lapply(1:nrow(binary_mat), function(i) {
    x = binary_mat[i, ]
    rle_x = rle(x)
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    schulter_idx = c()
    for (j in seq_along(values)) {
      if (values[j] == 1 && lengths[j] >= 4) {
        start_pos = starts[j]
        end_pos = ends[j]
        schulter_idx = c(schulter_idx, mean(start_pos:end_pos))
      }
    }
    
    if (length(schulter_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = schulter_idx
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}
```


### Schulterpunkte für Kontrolle
```{r} 
#vorübergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_Kontrolle = ifelse(Mittelwerte_Kontrolle > 2, 1, 0) # wenn größer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vorübergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife über alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_Kontrolle)) {
  Protein = Maxima_Mittelwerte_Kontrolle$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_Kontrolle$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen für die Spalten berechnen (Grenzen prüfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_Kontrolle), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_Kontrolle[Protein, Fraktions_bereich] = 0
}

Schulterpunkte_Kontrolle = find_shoulders(Schulter_Mittelwerte_Kontrolle, Proteinnamen)

```

### Schulterpunkte für RNAse

```{r}
#vorübergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_RNAse = ifelse(Mittelwerte_RNAse > 2, 1, 0) # wenn größer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vorübergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife über alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_RNAse)) {
  Protein = Maxima_Mittelwerte_RNAse$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_RNAse$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen für die Spalten berechnen (Grenzen prüfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_RNAse), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_RNAse[Protein, Fraktions_bereich] = 0
}


Schulterpunkte_RNAse = find_shoulders(Schulter_Mittelwerte_RNAse, Proteinnamen)
```

# es gibt nicht viele Schulterpunkte bei 2,5 die frage ist nur ob wir die entfernen müssen

#Gaussian Fit
#schauen was der kleinste quadratische Abstand zu unseren Daten ist. Wie viele Gauß-Kurven am besten.
#Oft kommen NA-Werte raus
#erste Code: RNAse und Kontrolle gleichzeitig
#zweiter Code: Nur Kontrolle --> kommen andere Werte raus :(
```{r}
n_proteins <- nrow(Mittelwerte_Kontrolle)
x_vals <- 1:ncol(Mittelwerte_Kontrolle)

# Ergebnis-Container
best_fit_params_ctrl <- matrix(NA, nrow=n_proteins, ncol=18) # max 6 * (C, mean, sigma)
best_fit_residuals_ctrl <- rep(NA, n_proteins)
best_fit_npeaks_ctrl <- rep(NA, n_proteins)

best_fit_params_rnase <- matrix(NA, nrow=n_proteins, ncol=18)
best_fit_residuals_rnase <- rep(NA, n_proteins)
best_fit_npeaks_rnase <- rep(NA, n_proteins)

# Hilfsfunktion: Gauß-Kurve; berechnet y-Wert einer Gauß-Kurve; C=Höhe; mean = Zentrum des Peaks; sigma = Breite
gaussian <- function(x, C, mean, sigma) {
  C * exp(- (x - mean)^2 / (2 * sigma^2))
}

# Main Loop
for (i in 1:n_proteins) {
  for (condition in c("ctrl", "rnase")) {
    
    # Y-Werte holen
    y <- as.numeric(if (condition == "ctrl") Mittelwerte_Kontrolle[i, ] else Mittelwerte_RNAse[i, ])
    
    best_residual <- Inf #als Platzhalter für etrem große Werte
    best_params <- rep(NA, 18)
    best_n <- NA
    
    for (n_peaks in 1:6) {
      n_params <- n_peaks * 3 #jede Gauß-Kurve hat drei Parameter
      start_params <- numeric()
      
      for (j in 1:n_peaks) {
        Cj <- max(y, na.rm=TRUE) / n_peaks #max(y) ist der höchste Wert im Proteinprofil → stellt die maximale Intensität dar.Die Division durch n_peaks verteilt diese Gesamtintensität gleichmäßig auf alle Peaks.!Das ist ein Startwert, nicht das endgültige Ergebnis – die Optimierung sucht später bessere Werte.!
        meanj <- which.max(y)
        sigmaj <- 2 #2 ist ein konstanter Startwert, d.h. man nimmt zunächst an, dass der Peak eine gewisse Breite hat.Auch dieser Wert wird später durch das Fit-Verfahren optimiert.
        start_params <- c(start_params, Cj, meanj, sigmaj) #So entsteht ein vollständiger Parametervektor mit Länge n_peaks × 3, der dann in optim() als Startwert dient.
      }
      
      fit <- try( #Der ganze Block wird mit try(...) umhüllt, um Fehler bei der Optimierung (z. B. wegen schlechter Startwerte) abzufangen. Wenn ein Fehler passiert, wird kein Abbruch erzeugt, sondern einfach fit als Fehlerobjekt gespeichert (silent = TRUE).
        optim( #Die Funktion optim() versucht, die Parameter für die Summe der Gauß-Kurven so zu optimieren, dass die Differenz zur gemessenen Kurve minimal ist.
          par = start_params,
          fn = function(par) {
            y_fit <- rep(0, length(x_vals)) #y_fit ist die Summe aller Gauß-Kurven, die aktuell mit den Parametern par berechnet werden.
            for (j in 1:n_peaks) {
              idx <- (j - 1) * 3 + 1
              y_fit <- y_fit + gaussian(x_vals, par[idx], par[idx+1], par[idx+2]) #Die Parameter im Vektor par sind in Blöcken von 3 hintereinander gespeichert. gaussian(x_vals, C, mean, sigma) berechnet eine Gauß-Kurve.

            } #Es werden alle n_peaks Kurven berechnet und aufsummiert.
            sum((y - y_fit)^2) #Fehlersumme; der Abstand zwischen dem Modell (y_fit) und den echten Daten (y)
          },
          method = "L-BFGS-B", #Ein robuster Optimierungsalgorithmus, der Grenzen (Bounds) erlaubt.
          lower = rep(c(0, 1, 0.1), n_peaks), #Grenzen für die Parameter (je Kurve):C ≥ 0 → Amplitude darf nicht negativ sein.mean ≥ 1 → Muss innerhalb der x-Werte liegen.sigma ≥ 0.1 → Verhindert zu enge, instabile Peaks.
          upper = rep(c(Inf, length(x_vals), Inf), n_peaks) #Obere Grenzen:C darf beliebig groß werden.mean darf maximal die letzte x-Position sein.sigma ist unbegrenzt.
        ), silent = TRUE
      )
      
      if (!inherits(fit, "try-error") && fit$value < best_residual) { #Prüft, ob bei der Optimierung kein Fehler aufgetreten ist.→ try() gibt ein spezielles Objekt vom Typ "try-error" zurück, wenn etwas schiefläuft.→ Mit !inherits(...) wird sichergestellt, dass der Fit gültig ist.
        best_residual <- fit$value
        best_params[1:n_params] <- fit$par
        best_n <- n_peaks
      }
    }
    
    # Ergebnisse speichern
    if (condition == "ctrl") {
      best_fit_params_ctrl[i, ] <- best_params
      best_fit_residuals_ctrl[i] <- best_residual
      best_fit_npeaks_ctrl[i] <- best_n
    } else {
      best_fit_params_rnase[i, ] <- best_params
      best_fit_residuals_rnase[i] <- best_residual
      best_fit_npeaks_rnase[i] <- best_n
    }
  }
}

# Ergebnisse in DataFrames
fit_results_ctrl <- data.frame(
  Protein = rownames(Mittelwerte_Kontrolle),
  npeaks = best_fit_npeaks_ctrl,
  residual = best_fit_residuals_ctrl,
  matrix(best_fit_params_ctrl, ncol = 18, byrow = FALSE)
)

fit_results_rnase <- data.frame(
  Protein = rownames(Mittelwerte_RNAse),
  npeaks = best_fit_npeaks_rnase,
  residual = best_fit_residuals_rnase,
  matrix(best_fit_params_rnase, ncol = 18, byrow = FALSE)
)

# Spaltennamen setzen
param_names <- unlist(lapply(1:6, function(j) c(paste0("C", j), paste0("mean", j), paste0("sigma", j))))
colnames(fit_results_ctrl)[4:21] <- param_names
colnames(fit_results_rnase)[4:21] <- param_names

# Beispielausgabe
head(fit_results_ctrl)
head(fit_results_rnase)
```
```{r}
# Hilfsfunktion: Gauß-Kurve
gaussian <- function(x, C, mean, sigma) {
  C * exp(- (x - mean)^2 / (2 * sigma^2))
}

# x-Werte (Spaltenindex) und Proteinanzahl
x_vals <- 1:ncol(Mittelwerte_Kontrolle)
n_proteins <- nrow(Mittelwerte_Kontrolle)

# Ergebnis-Container
fit_results_ctrl <- data.frame(
  Protein = rownames(Mittelwerte_Kontrolle),
  npeaks = NA,
  residual = NA,
  matrix(NA, nrow = n_proteins, ncol = 18)
)
param_names <- unlist(lapply(1:6, function(j) c(paste0("C", j), paste0("mean", j), paste0("sigma", j))))
colnames(fit_results_ctrl)[4:21] <- param_names

# Hauptschleife über alle Proteine
for (i in 1:n_proteins) {
  y <- as.numeric(Mittelwerte_Kontrolle[i, ])
  
  best_residual <- Inf
  best_params <- rep(NA, 18)
  best_npeaks <- NA
  
  for (n_peaks in 1:6) {
    n_params <- n_peaks * 3
    start_params <- rep(c(max(y), which.max(y), 2), n_peaks)
    
    fit <- try(
      optim(
        par = start_params,
        fn = function(par) {
          y_fit <- rep(0, length(x_vals))
          for (j in 1:n_peaks) {
            idx <- (j - 1) * 3 + 1
            y_fit <- y_fit + gaussian(x_vals, par[idx], par[idx+1], par[idx+2])
          }
          sum((y - y_fit)^2)
        },
        method = "L-BFGS-B",
        lower = rep(c(0, 1, 0.1), n_peaks),
        upper = rep(c(Inf, length(x_vals), Inf), n_peaks)
      ),
      silent = TRUE
    )
    
    if (!inherits(fit, "try-error") && fit$value < best_residual) {
      best_residual <- fit$value
      best_params[1:n_params] <- fit$par
      best_npeaks <- n_peaks
    }
  }
  
  # Speichern
  fit_results_ctrl[i, 2] <- best_npeaks
  fit_results_ctrl[i, 3] <- best_residual
  fit_results_ctrl[i, 4:(3 + length(best_params))] <- best_params
}
head(fit_results_ctrl)
```


## Zusammenführen der Werte
Ich würde das nochmal bisschen verändern aber so funktioniert es auf jeden Fall und wir haben Tabellen in denen jetzt alle Maxima & Schulerpunkte haben zum Weiterarbeiten

```{r}
# Für Schulterpunkte Wert hinzufügen
Schulterpunkte_Kontrolle$Fraktion_gerundet = round(Schulterpunkte_Kontrolle$Fraktion)
Schulterpunkte_Kontrolle$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_Kontrolle[zeile, fraktion]
}, Schulterpunkte_Kontrolle$Zeile, Schulterpunkte_Kontrolle$Fraktion_gerundet)

Schulterpunkte_RNAse$Fraktion_gerundet = round(Schulterpunkte_RNAse$Fraktion)
Schulterpunkte_RNAse$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_RNAse[zeile, fraktion]
}, Schulterpunkte_RNAse$Zeile, Schulterpunkte_RNAse$Fraktion_gerundet)

# Markieren und zusammenfügen Kontrolle
Maxima_Mittelwerte_Kontrolle$Typ = "Maxima"
Schulterpunkte_Kontrolle$Typ = "Schulter"

Combined_Kontrolle = rbind(
  Maxima_Mittelwerte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_Kontrolle = Combined_Kontrolle[order(Combined_Kontrolle$Zeile, Combined_Kontrolle$Fraktion), ]

# Markieren und zusammenfügen RNAse
Maxima_Mittelwerte_RNAse$Typ = "Maxima"
Schulterpunkte_RNAse$Typ = "Schulter"

Combined_RNAse = rbind(
  Maxima_Mittelwerte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_RNAse = Combined_RNAse[order(Combined_RNAse$Zeile, Combined_RNAse$Fraktion), ]
```



# Vergleich von RNAse & Kontrolle
```{r}
# Bestimmung der p-Werte für die verschiedenen Maxima

# funktioniert noch nicht
# Liste deiner Replikat-Tabellen
ctrl_reps = list(Ctrl1_norm, Ctrl2_norm, Ctrl3_norm)
rnase_reps = list(RNAse1_norm, RNAse3_norm, RNAse3_norm)

# Maxima aus beiden Treatments zusammenführen
peaks_ctrl = data.frame(Protein = Combined_Kontrolle$Protein, Fraktion = Combined_Kontrolle$Fraktion, Maximum = Combined_Kontrolle$Wert)
peaks_rnase = data.frame(Protein = Combined_RNAse$Protein, Fraktion = Combined_RNAse$Fraktion, Maximum = Combined_RNAse$Wert)

# Kombinierte Peaks
combined_peaks = unique(rbind(peaks_ctrl, peaks_rnase))

# Ergebnis-Tabelle 
results = data.frame()

for (i in 1:nrow(combined_peaks)) {
  protein = combined_peaks$Protein[i]
  fraktion = as.character(combined_peaks$Fraktion[i])

  # Hole Werte aus allen 3 Kontroll-Replikaten  # ab hier Fehler 
  ctrl_vals = sapply(ctrl_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })

  # Hole Werte aus allen 3 RNase-Replikaten
  rnase_vals = sapply(rnase_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })

  # Entferne NA-Werte
  ctrl_vals = na.omit(ctrl_vals)
  rnase_vals = na.omit(rnase_vals)

  # Wenn nötig: Mini-Störung hinzufügen bei identischen Werten
  if (length(ctrl_vals) >= 2 && all(abs(ctrl_vals - ctrl_vals[1]) < 1e-10)) {
    ctrl_vals[2] <- ctrl_vals[2] + 1e-6
  }
  if (length(rnase_vals) >= 2 && all(abs(rnase_vals - rnase_vals[1]) < 1e-10)) {
    rnase_vals[2] <- rnase_vals[2] + 1e-6
  }

  # t-Test nur wenn beide Gruppen mindestens 2 Werte haben
  

  if (length(ctrl_vals) >= 2 && length(rnase_vals) >= 2) {
    ftest_p <- tryCatch(var.test(ctrl_vals, rnase_vals)$p.value, error = function(e) NA)
    t_p <- tryCatch(
      t.test(ctrl_vals, rnase_vals, var.equal = (ftest_p > 0.05))$p.value,
      error = function(e) NA
    )
  } else {
    t_p <- NA
  }

  # Ergebnis speichern
  results = rbind(results, data.frame(
    Protein = protein,
    Fraktion = as.integer(fraktion),
    p_value = t_p
  ))
}

# FDR-Korrektur
results$adj_p = p.adjust(results$p_value, method = "BH")

```



```{r}
plot(1:25, Mittelwerte_Kontrolle[64,], type = "l", col = "blue",
     xlab = "Fraktion", ylab = "Intensität", main = "Proteinverteilung")


# plot(1:25, RNAse1_norm[58,], type = "l", col = "blue",
    # xlab = "Fraktion", ylab = "Intensität", main = "Proteinverteilung")

```




















## Jettes Plan
- Funktionen erstellen für verschiedene anzahl an peaks (gucken, wie viele es generell gibt) mit Parametern Mittelwert, Standardabweichung, Amplitude, die Fehlerberechnung beinhalten und somit für jedes Protein für die jeweilige Verteilung optimiert werden können
- mit der optimierung für jedes Protein (noch bei den Mittelwerten der replikate) die passenden Parameter erhalten
- also optimierung für jeden der drei parameter und für jedes Treatment
- optimierte parameter abspeichern als vektor
- danach erst Gauß fit für jedes Replikat durchführen

https://chatgpt.com/share/683b2417-6030-8006-b6d2-479f6f34f641

------------------------------------------------------------------------

### 🟩 **Was im Protokoll gemacht wurde:**

1️⃣ **Teil 2 (Peaks & Fit-Parameter)** Das Gauß-Fitting in Teil 2 wurde auf den **gemittelten Profilen** (also dem Durchschnitt aus je drei Replikaten) gemacht:

-   **1 Mittelwert-Kurve** für Kontrolle (CTRL)
-   **1 Mittelwert-Kurve** für RNase

➡️ Ziel:

-   **robuste Erkennung von Maxima und Schultern**
-   „globale“ Fit-Parameter (Amplitude, Lage, Breite) der **Durchschnittskurve** pro Protein und Bedingung
-   diese Maxima-Positionen dienen als „Startpunkte“ für die Fits in Teil 3

------------------------------------------------------------------------

2️⃣ **Teil 3 (Gaussian Fit auf Einzeldaten)** Hier wurde das **Gauß-Fitting für alle 6 Replikate einzeln** durchgeführt!

-   **3 Replikate für Kontrolle (ctrl1, ctrl2, ctrl3)**
-   **3 Replikate für RNase (rnase1, rnase2, rnase3)**

➡️ Ziel:

-   **individuelle Fit-Parameter** pro Replikat (z.B. Amplitude = Proteinmenge in diesem Peak in diesem Replikat!)
-   diese Werte werden später (Teil 5) mit einem **t-Test** zwischen den Bedingungen (CTRL vs. RNase) verglichen.

------------------------------------------------------------------------

### 🟡 **Zusammengefasst:**

| Phase | Datenbasis | Ziel |
|---------------|------------------|---------------------------------------|
| **Teil 2** | Mittelwert-Kurve aus 3 Replikaten | Finden von Peaks und deren Startparameter (robust, stabil) |
| **Teil 3** | 6 Replikat-Kurven (je Protein) | Fit-Parameter (Amplitude, Position, Breite) pro Replikat ermitteln |

------------------------------------------------------------------------

✅ **Also: Das finale Gauß-Fitting für die t-Tests wird an allen 6 Replikaten gemacht!** ❌ **Nicht nur auf den Mittelwerten!** ✅ Aber die Mittelwert-Kurve liefert die „guten Startwerte“, damit die Fits bei den Einzel-Replikaten stabiler sind.

------------------------------------------------------------------------

💡 **Falls du möchtest**, kann ich dir das gerne auch als „Schema“ zeichnen (z.B. Flowchart), wie das Protokoll hier abläuft! 🚀
