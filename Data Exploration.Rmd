---
title: "Exploration"
output: html_document
date: "2025-05-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
MS_Table_norm = read.table("MS_Table.norm.csv", header=TRUE, row.names=1, sep = ",")
```

# Data exploration

```{r}
Fraktionsnamen = c('Fraction1_Ctrl', 'Fraction1_RNAse', 'Fraction2_Ctrl', 'Fraction2_RNAse','Fraction3_Ctrl', 'Fraction3_RNAse','Fraction4_Ctrl', 'Fraction4_RNAse','Fraction5_Ctrl', 'Fraction5_RNAse','Fraction6_Ctrl', 'Fraction6_RNAse','Fraction7_Ctrl', 'Fraction7_RNAse','Fraction8_Ctrl', 'Fraction8_RNAse','Fraction9_Ctrl', 'Fraction9_RNAse','Fraction10_Ctrl', 'Fraction10_RNAse','Fraction11_Ctrl', 'Fraction11_RNAse','Fraction12_Ctrl', 'Fraction12_RNAse','Fraction13_Ctrl', 'Fraction13_RNAse','Fraction14_Ctrl', 'Fraction14_RNAse','Fraction15_Ctrl', 'Fraction15_RNAse','Fraction16_Ctrl', 'Fraction16_RNAse','Fraction17_Ctrl', 'Fraction17_RNAse','Fraction18_Ctrl', 'Fraction18_RNAse','Fraction19_Ctrl', 'Fraction19_RNAse','Fraction20_Ctrl', 'Fraction20_RNAse','Fraction21_Ctrl', 'Fraction21_RNAse','Fraction22_Ctrl', 'Fraction22_RNAse','Fraction23_Ctrl', 'Fraction23_RNAse','Fraction24_Ctrl', 'Fraction24_RNAse','Fraction25_Ctrl', 'Fraction25_RNAse')
```

```{r}
Proteinnamen = rownames(MS_Table)
```



```{r} 
# Subtabellen f√ºr jedes Replikat
for (i in 1:6) {

  spalten_index = seq(from = i, to = 150, by = 6) 
  teilmatrix = MS_Table_norm[, spalten_index]
  
  assign(Treatmentnamen[i], teilmatrix) # neue Subtabellen, richtig benannt
}
```

```{r}
# Mittelwerte f√ºr Treatments als Tabelle

Mittelwert_matrix = t(apply(MS_Table_norm, 1, function(row) {
  sapply(1:50, function(i) {
    spalten_index = ((i - 1) * 3 + 1):(i * 3)
    mean(row[spalten_index])
  })
}))

# Jeden zweiten Mittelwert ausw√§hlen
Mittelwerte_Kontrolle = as.data.frame(Mittelwert_matrix[, seq(1, 50, by=2)])
Mittelwerte_RNAse = as.data.frame(Mittelwert_matrix[, seq(2, 50, by=2)])

colnames(Mittelwerte_Kontrolle) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
colnames(Mittelwerte_RNAse) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
  
```


## Maxima Bestimmung
Ber√ºcksichtigt: Plateaus, gespaltene Peaks, Randmaxima, Threshold

```{r}
find_maxima = function(mat, threshold = 2) {
  result = do.call(rbind, lapply(1:nrow(mat), function(i) {
    x = mat[i, ]
    
    # Normale Maxima: zweite Ableitung mit Vorzeichenwechsel
    idx = which(diff(sign(diff(x))) == -2) + 1 
    
    # Plateaumaxima
    rle_x = rle(x)  # Run-Length-Encoding der Werte
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    plateau_idx = c()
    for (j in seq_along(values)) {
      # Nur Plateaus mit L√§nge > 1 pr√ºfen
      if (lengths[j] > 1) {
        start_pos = starts[j]
        end_pos = ends[j]
        
        # Werte links und rechts des Plateaus
        left_val = if (start_pos > 1) x[start_pos - 1] else -Inf
        right_val = if (end_pos < length(x)) x[end_pos + 1] else -Inf
        
        # Plateau ist lokales Maximum, wenn Wert >= Nachbarn
        if (values[j] >= left_val && values[j] >= right_val) {
          # Plateau-Maximum: Indize des Plateausstartpunkts
          plateau_idx = c(plateau_idx, mean(start_pos:end_pos))
        }
      }
    }
    
    # Kombination von normalen Maxima und Plateau-Maxima
    all_idx = sort(unique(c(idx, plateau_idx))) #unique: falls Werte doppelt werden sie entfernt, sort: sotieren der Indizes in aufsteigender Reihenfolge
    
    # Randmaxima pr√ºfen
    if (x[1] > x[2]) {all_idx = c(1, all_idx)}
    if (x[length(x)] > x[length(x)-1]) {all_idx = c(all_idx, length(x))}
    
    # nur Werte > threshold = 2% behalten
    all_idx = all_idx[x[all_idx] > threshold]
    
    # Peaks bereinigen: Wenn zwei Peaks nur einen Wert dazwischen haben, den kleineren entfernen
    if (length(all_idx) >= 2) {
      to_remove = c()
      for (k in 1:(length(all_idx)-1)) {
        if (all_idx[k+1] - all_idx[k] == 2) {
          # Indizes der Peaks
          peak1 = all_idx[k]
          peak2 = all_idx[k+1]
          if (x[peak1] >= x[peak2]) {
            to_remove = c(to_remove, peak2)
          } else {
            to_remove = c(to_remove, peak1)
          }
        }
      } # Entfernen des niedrigeren Wert
      if (length(to_remove) > 0) {
        all_idx = setdiff(all_idx, to_remove)
      }
    }
    
    if (length(all_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = all_idx,
        Wert = x[all_idx]
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}

# Maxima f√ºr Mittelwerte aus Triplikaten
Mittelwerte_Kontrolle_mat = as.matrix(sapply(Mittelwerte_Kontrolle, as.numeric))
Mittelwerte_RNAse_mat = as.matrix(sapply(Mittelwerte_RNAse, as.numeric))

Maxima_Mittelwerte_Kontrolle = find_maxima(Mittelwerte_Kontrolle_mat)
Maxima_Mittelwerte_RNAse = find_maxima(Mittelwerte_RNAse_mat)
```

## Schulterpunkte

```{r}
# Funktion zum Finden der Schulterpunkte
find_shoulders = function(binary_mat, Proteinnamen) {
  result = do.call(rbind, lapply(1:nrow(binary_mat), function(i) {
    x = binary_mat[i, ]
    rle_x = rle(x)
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    schulter_idx = c()
    for (j in seq_along(values)) {
      if (values[j] == 1 && lengths[j] >= 4) {
        start_pos = starts[j]
        end_pos = ends[j]
        schulter_idx = c(schulter_idx, mean(start_pos:end_pos))
      }
    }
    
    if (length(schulter_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = schulter_idx
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}
```


### Schulterpunkte f√ºr Kontrolle
```{r} 
#vor√ºbergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_Kontrolle = ifelse(Mittelwerte_Kontrolle > 2, 1, 0) # wenn gr√∂√üer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vor√ºbergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife √ºber alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_Kontrolle)) {
  Protein = Maxima_Mittelwerte_Kontrolle$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_Kontrolle$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen f√ºr die Spalten berechnen (Grenzen pr√ºfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_Kontrolle), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ¬±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_Kontrolle[Protein, Fraktions_bereich] = 0
}

Schulterpunkte_Kontrolle = find_shoulders(Schulter_Mittelwerte_Kontrolle, Proteinnamen)

```

### Schulterpunkte f√ºr RNAse

```{r}
#vor√ºbergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_RNAse = ifelse(Mittelwerte_RNAse > 2, 1, 0) # wenn gr√∂√üer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vor√ºbergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife √ºber alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_RNAse)) {
  Protein = Maxima_Mittelwerte_RNAse$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_RNAse$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen f√ºr die Spalten berechnen (Grenzen pr√ºfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_RNAse), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ¬±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_RNAse[Protein, Fraktions_bereich] = 0
}


Schulterpunkte_RNAse = find_shoulders(Schulter_Mittelwerte_RNAse, Proteinnamen)
```

# es gibt nicht viele Schulterpunkte bei 2,5 die frage ist nur ob wir die entfernen m√ºssen

#Gaussian Fit
#schauen was der kleinste quadratische Abstand zu unseren Daten ist. Wie viele Gau√ü-Kurven am besten.
#Oft kommen NA-Werte raus
#erste Code: RNAse und Kontrolle gleichzeitig
#zweiter Code: Nur Kontrolle --> kommen andere Werte raus :(
```{r}
n_proteins <- nrow(Mittelwerte_Kontrolle)
x_vals <- 1:ncol(Mittelwerte_Kontrolle)

# Ergebnis-Container
best_fit_params_ctrl <- matrix(NA, nrow=n_proteins, ncol=18) # max 6 * (C, mean, sigma)
best_fit_residuals_ctrl <- rep(NA, n_proteins)
best_fit_npeaks_ctrl <- rep(NA, n_proteins)

best_fit_params_rnase <- matrix(NA, nrow=n_proteins, ncol=18)
best_fit_residuals_rnase <- rep(NA, n_proteins)
best_fit_npeaks_rnase <- rep(NA, n_proteins)

# Hilfsfunktion: Gau√ü-Kurve; berechnet y-Wert einer Gau√ü-Kurve; C=H√∂he; mean = Zentrum des Peaks; sigma = Breite
gaussian <- function(x, C, mean, sigma) {
  C * exp(- (x - mean)^2 / (2 * sigma^2))
}

# Main Loop
for (i in 1:n_proteins) {
  for (condition in c("ctrl", "rnase")) {
    
    # Y-Werte holen
    y <- as.numeric(if (condition == "ctrl") Mittelwerte_Kontrolle[i, ] else Mittelwerte_RNAse[i, ])
    
    best_residual <- Inf #als Platzhalter f√ºr etrem gro√üe Werte
    best_params <- rep(NA, 18)
    best_n <- NA
    
    for (n_peaks in 1:6) {
      n_params <- n_peaks * 3 #jede Gau√ü-Kurve hat drei Parameter
      start_params <- numeric()
      
      for (j in 1:n_peaks) {
        Cj <- max(y, na.rm=TRUE) / n_peaks #max(y) ist der h√∂chste Wert im Proteinprofil ‚Üí stellt die maximale Intensit√§t dar.Die Division durch n_peaks verteilt diese Gesamtintensit√§t gleichm√§√üig auf alle Peaks.!Das ist ein Startwert, nicht das endg√ºltige Ergebnis ‚Äì die Optimierung sucht sp√§ter bessere Werte.!
        meanj <- which.max(y)
        sigmaj <- 2 #2 ist ein konstanter Startwert, d.h. man nimmt zun√§chst an, dass der Peak eine gewisse Breite hat.Auch dieser Wert wird sp√§ter durch das Fit-Verfahren optimiert.
        start_params <- c(start_params, Cj, meanj, sigmaj) #So entsteht ein vollst√§ndiger Parametervektor mit L√§nge n_peaks √ó 3, der dann in optim() als Startwert dient.
      }
      
      fit <- try( #Der ganze Block wird mit try(...) umh√ºllt, um Fehler bei der Optimierung (z.‚ÄØB. wegen schlechter Startwerte) abzufangen. Wenn ein Fehler passiert, wird kein Abbruch erzeugt, sondern einfach fit als Fehlerobjekt gespeichert (silent = TRUE).
        optim( #Die Funktion optim() versucht, die Parameter f√ºr die Summe der Gau√ü-Kurven so zu optimieren, dass die Differenz zur gemessenen Kurve minimal ist.
          par = start_params,
          fn = function(par) {
            y_fit <- rep(0, length(x_vals)) #y_fit ist die Summe aller Gau√ü-Kurven, die aktuell mit den Parametern par berechnet werden.
            for (j in 1:n_peaks) {
              idx <- (j - 1) * 3 + 1
              y_fit <- y_fit + gaussian(x_vals, par[idx], par[idx+1], par[idx+2]) #Die Parameter im Vektor par sind in Bl√∂cken von 3 hintereinander gespeichert. gaussian(x_vals, C, mean, sigma) berechnet eine Gau√ü-Kurve.

            } #Es werden alle n_peaks Kurven berechnet und aufsummiert.
            sum((y - y_fit)^2) #Fehlersumme; der Abstand zwischen dem Modell (y_fit) und den echten Daten (y)
          },
          method = "L-BFGS-B", #Ein robuster Optimierungsalgorithmus, der Grenzen (Bounds) erlaubt.
          lower = rep(c(0, 1, 0.1), n_peaks), #Grenzen f√ºr die Parameter (je Kurve):C ‚â• 0 ‚Üí Amplitude darf nicht negativ sein.mean ‚â• 1 ‚Üí Muss innerhalb der x-Werte liegen.sigma ‚â• 0.1 ‚Üí Verhindert zu enge, instabile Peaks.
          upper = rep(c(Inf, length(x_vals), Inf), n_peaks) #Obere Grenzen:C darf beliebig gro√ü werden.mean darf maximal die letzte x-Position sein.sigma ist unbegrenzt.
        ), silent = TRUE
      )
      
      if (!inherits(fit, "try-error") && fit$value < best_residual) { #Pr√ºft, ob bei der Optimierung kein Fehler aufgetreten ist.‚Üí try() gibt ein spezielles Objekt vom Typ "try-error" zur√ºck, wenn etwas schiefl√§uft.‚Üí Mit !inherits(...) wird sichergestellt, dass der Fit g√ºltig ist.
        best_residual <- fit$value
        best_params[1:n_params] <- fit$par
        best_n <- n_peaks
      }
    }
    
    # Ergebnisse speichern
    if (condition == "ctrl") {
      best_fit_params_ctrl[i, ] <- best_params
      best_fit_residuals_ctrl[i] <- best_residual
      best_fit_npeaks_ctrl[i] <- best_n
    } else {
      best_fit_params_rnase[i, ] <- best_params
      best_fit_residuals_rnase[i] <- best_residual
      best_fit_npeaks_rnase[i] <- best_n
    }
  }
}

# Ergebnisse in DataFrames
fit_results_ctrl <- data.frame(
  Protein = rownames(Mittelwerte_Kontrolle),
  npeaks = best_fit_npeaks_ctrl,
  residual = best_fit_residuals_ctrl,
  matrix(best_fit_params_ctrl, ncol = 18, byrow = FALSE)
)

fit_results_rnase <- data.frame(
  Protein = rownames(Mittelwerte_RNAse),
  npeaks = best_fit_npeaks_rnase,
  residual = best_fit_residuals_rnase,
  matrix(best_fit_params_rnase, ncol = 18, byrow = FALSE)
)

# Spaltennamen setzen
param_names <- unlist(lapply(1:6, function(j) c(paste0("C", j), paste0("mean", j), paste0("sigma", j))))
colnames(fit_results_ctrl)[4:21] <- param_names
colnames(fit_results_rnase)[4:21] <- param_names

# Beispielausgabe
head(fit_results_ctrl)
head(fit_results_rnase)
```
```{r}
# Hilfsfunktion: Gau√ü-Kurve
gaussian <- function(x, C, mean, sigma) {
  C * exp(- (x - mean)^2 / (2 * sigma^2))
}

# x-Werte (Spaltenindex) und Proteinanzahl
x_vals <- 1:ncol(Mittelwerte_Kontrolle)
n_proteins <- nrow(Mittelwerte_Kontrolle)

# Ergebnis-Container
fit_results_ctrl <- data.frame(
  Protein = rownames(Mittelwerte_Kontrolle),
  npeaks = NA,
  residual = NA,
  matrix(NA, nrow = n_proteins, ncol = 18)
)
param_names <- unlist(lapply(1:6, function(j) c(paste0("C", j), paste0("mean", j), paste0("sigma", j))))
colnames(fit_results_ctrl)[4:21] <- param_names

# Hauptschleife √ºber alle Proteine
for (i in 1:n_proteins) {
  y <- as.numeric(Mittelwerte_Kontrolle[i, ])
  
  best_residual <- Inf
  best_params <- rep(NA, 18)
  best_npeaks <- NA
  
  for (n_peaks in 1:6) {
    n_params <- n_peaks * 3
    start_params <- rep(c(max(y), which.max(y), 2), n_peaks)
    
    fit <- try(
      optim(
        par = start_params,
        fn = function(par) {
          y_fit <- rep(0, length(x_vals))
          for (j in 1:n_peaks) {
            idx <- (j - 1) * 3 + 1
            y_fit <- y_fit + gaussian(x_vals, par[idx], par[idx+1], par[idx+2])
          }
          sum((y - y_fit)^2)
        },
        method = "L-BFGS-B",
        lower = rep(c(0, 1, 0.1), n_peaks),
        upper = rep(c(Inf, length(x_vals), Inf), n_peaks)
      ),
      silent = TRUE
    )
    
    if (!inherits(fit, "try-error") && fit$value < best_residual) {
      best_residual <- fit$value
      best_params[1:n_params] <- fit$par
      best_npeaks <- n_peaks
    }
  }
  
  # Speichern
  fit_results_ctrl[i, 2] <- best_npeaks
  fit_results_ctrl[i, 3] <- best_residual
  fit_results_ctrl[i, 4:(3 + length(best_params))] <- best_params
}
head(fit_results_ctrl)
```


## Zusammenf√ºhren der Werte
Ich w√ºrde das nochmal bisschen ver√§ndern aber so funktioniert es auf jeden Fall und wir haben Tabellen in denen jetzt alle Maxima & Schulerpunkte haben zum Weiterarbeiten

```{r}
# F√ºr Schulterpunkte Wert hinzuf√ºgen
Schulterpunkte_Kontrolle$Fraktion_gerundet = round(Schulterpunkte_Kontrolle$Fraktion)
Schulterpunkte_Kontrolle$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_Kontrolle[zeile, fraktion]
}, Schulterpunkte_Kontrolle$Zeile, Schulterpunkte_Kontrolle$Fraktion_gerundet)

Schulterpunkte_RNAse$Fraktion_gerundet = round(Schulterpunkte_RNAse$Fraktion)
Schulterpunkte_RNAse$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_RNAse[zeile, fraktion]
}, Schulterpunkte_RNAse$Zeile, Schulterpunkte_RNAse$Fraktion_gerundet)

# Markieren und zusammenf√ºgen Kontrolle
Maxima_Mittelwerte_Kontrolle$Typ = "Maxima"
Schulterpunkte_Kontrolle$Typ = "Schulter"

Combined_Kontrolle = rbind(
  Maxima_Mittelwerte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_Kontrolle = Combined_Kontrolle[order(Combined_Kontrolle$Zeile, Combined_Kontrolle$Fraktion), ]

# Markieren und zusammenf√ºgen RNAse
Maxima_Mittelwerte_RNAse$Typ = "Maxima"
Schulterpunkte_RNAse$Typ = "Schulter"

Combined_RNAse = rbind(
  Maxima_Mittelwerte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_RNAse = Combined_RNAse[order(Combined_RNAse$Zeile, Combined_RNAse$Fraktion), ]
```



# Vergleich von RNAse & Kontrolle
```{r}
# Bestimmung der p-Werte f√ºr die verschiedenen Maxima

# funktioniert noch nicht
# Liste deiner Replikat-Tabellen
ctrl_reps = list(Ctrl1_norm, Ctrl2_norm, Ctrl3_norm)
rnase_reps = list(RNAse1_norm, RNAse3_norm, RNAse3_norm)

# Maxima aus beiden Treatments zusammenf√ºhren
peaks_ctrl = data.frame(Protein = Combined_Kontrolle$Protein, Fraktion = Combined_Kontrolle$Fraktion, Maximum = Combined_Kontrolle$Wert)
peaks_rnase = data.frame(Protein = Combined_RNAse$Protein, Fraktion = Combined_RNAse$Fraktion, Maximum = Combined_RNAse$Wert)

# Kombinierte Peaks
combined_peaks = unique(rbind(peaks_ctrl, peaks_rnase))

# Ergebnis-Tabelle 
results = data.frame()

for (i in 1:nrow(combined_peaks)) {
  protein = combined_peaks$Protein[i]
  fraktion = as.character(combined_peaks$Fraktion[i])

  # Hole Werte aus allen 3 Kontroll-Replikaten  # ab hier Fehler 
  ctrl_vals = sapply(ctrl_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })

  # Hole Werte aus allen 3 RNase-Replikaten
  rnase_vals = sapply(rnase_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })

  # Entferne NA-Werte
  ctrl_vals = na.omit(ctrl_vals)
  rnase_vals = na.omit(rnase_vals)

  # Wenn n√∂tig: Mini-St√∂rung hinzuf√ºgen bei identischen Werten
  if (length(ctrl_vals) >= 2 && all(abs(ctrl_vals - ctrl_vals[1]) < 1e-10)) {
    ctrl_vals[2] <- ctrl_vals[2] + 1e-6
  }
  if (length(rnase_vals) >= 2 && all(abs(rnase_vals - rnase_vals[1]) < 1e-10)) {
    rnase_vals[2] <- rnase_vals[2] + 1e-6
  }

  # t-Test nur wenn beide Gruppen mindestens 2 Werte haben
  

  if (length(ctrl_vals) >= 2 && length(rnase_vals) >= 2) {
    ftest_p <- tryCatch(var.test(ctrl_vals, rnase_vals)$p.value, error = function(e) NA)
    t_p <- tryCatch(
      t.test(ctrl_vals, rnase_vals, var.equal = (ftest_p > 0.05))$p.value,
      error = function(e) NA
    )
  } else {
    t_p <- NA
  }

  # Ergebnis speichern
  results = rbind(results, data.frame(
    Protein = protein,
    Fraktion = as.integer(fraktion),
    p_value = t_p
  ))
}

# FDR-Korrektur
results$adj_p = p.adjust(results$p_value, method = "BH")

```



```{r}
plot(1:25, Mittelwerte_Kontrolle[64,], type = "l", col = "blue",
     xlab = "Fraktion", ylab = "Intensit√§t", main = "Proteinverteilung")


# plot(1:25, RNAse1_norm[58,], type = "l", col = "blue",
    # xlab = "Fraktion", ylab = "Intensit√§t", main = "Proteinverteilung")

```




















## Jettes Plan
- Funktionen erstellen f√ºr verschiedene anzahl an peaks (gucken, wie viele es generell gibt) mit Parametern Mittelwert, Standardabweichung, Amplitude, die Fehlerberechnung beinhalten und somit f√ºr jedes Protein f√ºr die jeweilige Verteilung optimiert werden k√∂nnen
- mit der optimierung f√ºr jedes Protein (noch bei den Mittelwerten der replikate) die passenden Parameter erhalten
- also optimierung f√ºr jeden der drei parameter und f√ºr jedes Treatment
- optimierte parameter abspeichern als vektor
- danach erst Gau√ü fit f√ºr jedes Replikat durchf√ºhren

https://chatgpt.com/share/683b2417-6030-8006-b6d2-479f6f34f641

------------------------------------------------------------------------

### üü© **Was im Protokoll gemacht wurde:**

1Ô∏è‚É£ **Teil 2 (Peaks & Fit-Parameter)** Das Gau√ü-Fitting in Teil 2 wurde auf den **gemittelten Profilen** (also dem Durchschnitt aus je drei Replikaten) gemacht:

-   **1 Mittelwert-Kurve** f√ºr Kontrolle (CTRL)
-   **1 Mittelwert-Kurve** f√ºr RNase

‚û°Ô∏è Ziel:

-   **robuste Erkennung von Maxima und Schultern**
-   ‚Äûglobale‚Äú Fit-Parameter (Amplitude, Lage, Breite) der **Durchschnittskurve** pro Protein und Bedingung
-   diese Maxima-Positionen dienen als ‚ÄûStartpunkte‚Äú f√ºr die Fits in Teil 3

------------------------------------------------------------------------

2Ô∏è‚É£ **Teil 3 (Gaussian Fit auf Einzeldaten)** Hier wurde das **Gau√ü-Fitting f√ºr alle 6 Replikate einzeln** durchgef√ºhrt!

-   **3 Replikate f√ºr Kontrolle (ctrl1, ctrl2, ctrl3)**
-   **3 Replikate f√ºr RNase (rnase1, rnase2, rnase3)**

‚û°Ô∏è Ziel:

-   **individuelle Fit-Parameter** pro Replikat (z.B. Amplitude = Proteinmenge in diesem Peak in diesem Replikat!)
-   diese Werte werden sp√§ter (Teil 5) mit einem **t-Test** zwischen den Bedingungen (CTRL vs. RNase) verglichen.

------------------------------------------------------------------------

### üü° **Zusammengefasst:**

| Phase | Datenbasis | Ziel |
|---------------|------------------|---------------------------------------|
| **Teil 2** | Mittelwert-Kurve aus 3 Replikaten | Finden von Peaks und deren Startparameter (robust, stabil) |
| **Teil 3** | 6 Replikat-Kurven (je Protein) | Fit-Parameter (Amplitude, Position, Breite) pro Replikat ermitteln |

------------------------------------------------------------------------

‚úÖ **Also: Das finale Gau√ü-Fitting f√ºr die t-Tests wird an allen 6 Replikaten gemacht!** ‚ùå **Nicht nur auf den Mittelwerten!** ‚úÖ Aber die Mittelwert-Kurve liefert die ‚Äûguten Startwerte‚Äú, damit die Fits bei den Einzel-Replikaten stabiler sind.

------------------------------------------------------------------------

üí° **Falls du m√∂chtest**, kann ich dir das gerne auch als ‚ÄûSchema‚Äú zeichnen (z.B. Flowchart), wie das Protokoll hier abl√§uft! üöÄ
