---
title: "Exploration"
output: html_document
date: "2025-05-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
MS_Table_norm = read.table("MS_Table.norm.csv", header=TRUE, row.names=1, sep = ",")
```

# Data exploration

```{r}
Fraktionsnamen = c('Fraction1_Ctrl', 'Fraction1_RNAse', 'Fraction2_Ctrl', 'Fraction2_RNAse','Fraction3_Ctrl', 'Fraction3_RNAse','Fraction4_Ctrl', 'Fraction4_RNAse','Fraction5_Ctrl', 'Fraction5_RNAse','Fraction6_Ctrl', 'Fraction6_RNAse','Fraction7_Ctrl', 'Fraction7_RNAse','Fraction8_Ctrl', 'Fraction8_RNAse','Fraction9_Ctrl', 'Fraction9_RNAse','Fraction10_Ctrl', 'Fraction10_RNAse','Fraction11_Ctrl', 'Fraction11_RNAse','Fraction12_Ctrl', 'Fraction12_RNAse','Fraction13_Ctrl', 'Fraction13_RNAse','Fraction14_Ctrl', 'Fraction14_RNAse','Fraction15_Ctrl', 'Fraction15_RNAse','Fraction16_Ctrl', 'Fraction16_RNAse','Fraction17_Ctrl', 'Fraction17_RNAse','Fraction18_Ctrl', 'Fraction18_RNAse','Fraction19_Ctrl', 'Fraction19_RNAse','Fraction20_Ctrl', 'Fraction20_RNAse','Fraction21_Ctrl', 'Fraction21_RNAse','Fraction22_Ctrl', 'Fraction22_RNAse','Fraction23_Ctrl', 'Fraction23_RNAse','Fraction24_Ctrl', 'Fraction24_RNAse','Fraction25_Ctrl', 'Fraction25_RNAse')
```

```{r} 
# Subtabellen f√ºr jedes Replikat
for (i in 1:6) {

  spalten_index = seq(from = i, to = 150, by = 6) 
  teilmatrix = MS_Table_norm[, spalten_index]
  
  assign(Treatmentnamen[i], teilmatrix) # neue Subtabellen, richtig benannt
}
```

```{r}
# Mittelwerte f√ºr Treatments als Tabelle

Mittelwert_matrix = t(apply(MS_Table_norm, 1, function(row) {
  sapply(1:50, function(i) {
    spalten_index = ((i - 1) * 3 + 1):(i * 3)
    mean(row[spalten_index])
  })
}))

# Jeden zweiten Mittelwert ausw√§hlen
Mittelwerte_Kontrolle = as.data.frame(Mittelwert_matrix[, seq(1, 50, by=2)])
Mittelwerte_RNAse = as.data.frame(Mittelwert_matrix[, seq(2, 50, by=2)])

colnames(Mittelwerte_Kontrolle) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
colnames(Mittelwerte_RNAse) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
  
```


## Maxima Bestimmung
Ber√ºcksichtigt: Plateaus, gespaltene Peaks, Randmaxima, Threshold

```{r}
find_maxima = function(mat, threshold = 2) {
  result = do.call(rbind, lapply(1:nrow(mat), function(i) {
    x = mat[i, ]
    
    # Normale Maxima: zweite Ableitung mit Vorzeichenwechsel
    idx = which(diff(sign(diff(x))) == -2) + 1 
    
    # Plateaumaxima
    rle_x = rle(x)  # Run-Length-Encoding der Werte
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    plateau_idx = c()
    for (j in seq_along(values)) {
      # Nur Plateaus mit L√§nge > 1 pr√ºfen
      if (lengths[j] > 1) {
        start_pos = starts[j]
        end_pos = ends[j]
        
        # Werte links und rechts des Plateaus
        left_val = if (start_pos > 1) x[start_pos - 1] else -Inf
        right_val = if (end_pos < length(x)) x[end_pos + 1] else -Inf
        
        # Plateau ist lokales Maximum, wenn Wert >= Nachbarn
        if (values[j] >= left_val && values[j] >= right_val) {
          # Plateau-Maximum: Indize des Plateausstartpunkts
          plateau_idx = c(plateau_idx, mean(start_pos:end_pos))
        }
      }
    }
    
    # Kombination von normalen Maxima und Plateau-Maxima
    all_idx = sort(unique(c(idx, plateau_idx))) #unique: falls Werte doppelt werden sie entfernt, sort: sotieren der Indizes in aufsteigender Reihenfolge
    
    # Randmaxima pr√ºfen
    if (x[1] > x[2]) {all_idx = c(1, all_idx)}
    if (x[length(x)] > x[length(x)-1]) {all_idx = c(all_idx, length(x))}
    
    # nur Werte > threshold = 2% behalten
    all_idx = all_idx[x[all_idx] > threshold]
    
    # Peaks bereinigen: Wenn zwei Peaks nur einen Wert dazwischen haben, den kleineren entfernen
    if (length(all_idx) >= 2) {
      to_remove = c()
      for (k in 1:(length(all_idx)-1)) {
        if (all_idx[k+1] - all_idx[k] == 2) {
          # Indizes der Peaks
          peak1 = all_idx[k]
          peak2 = all_idx[k+1]
          if (x[peak1] >= x[peak2]) {
            to_remove = c(to_remove, peak2)
          } else {
            to_remove = c(to_remove, peak1)
          }
        }
      } # Entfernen des niedrigeren Wert
      if (length(to_remove) > 0) {
        all_idx = setdiff(all_idx, to_remove)
      }
    }
    
    if (length(all_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = all_idx,
        Wert = x[all_idx]
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}

# Maxima f√ºr Mittelwerte aus Triplikaten
Mittelwerte_Kontrolle_mat = as.matrix(sapply(Mittelwerte_Kontrolle, as.numeric))
Mittelwerte_RNAse_mat = as.matrix(sapply(Mittelwerte_RNAse, as.numeric))

Maxima_Mittelwerte_Kontrolle = find_maxima(Mittelwerte_Kontrolle_mat)
Maxima_Mittelwerte_RNAse = find_maxima(Mittelwerte_RNAse_mat)
```

## Schulterpunkte

```{r}
# vor√ºbergehendes Entfernen von Bereichen um Maxima in Tabelle  

Tabelle_f√ºr_Schulter = MS_Table_norm[]



```


# Vergleich von RNAse & Kontrolle
```{r}

```


```{r}
plot(1:25, Ctrl1_norm[2,], type = "l", col = "blue",
     xlab = "Fraktion", ylab = "Intensit√§t", main = "Proteinverteilung")


plot(1:25, RNAse1_norm[58,], type = "l", col = "blue",
     xlab = "Fraktion", ylab = "Intensit√§t", main = "Proteinverteilung")

```




















## Jettes Plan
- Funktionen erstellen f√ºr verschiedene anzahl an peaks (gucken, wie viele es generell gibt) mit Parametern Mittelwert, Standardabweichung, Amplitude, die Fehlerberechnung beinhalten und somit f√ºr jedes Protein f√ºr die jeweilige Verteilung optimiert werden k√∂nnen
- mit der optimierung f√ºr jedes Protein (noch bei den Mittelwerten der replikate) die passenden Parameter erhalten
- also optimierung f√ºr jeden der drei parameter und f√ºr jedes Treatment
- optimierte parameter abspeichern als vektor
- danach erst Gau√ü fit f√ºr jedes Replikat durchf√ºhren

https://chatgpt.com/share/683b2417-6030-8006-b6d2-479f6f34f641

------------------------------------------------------------------------

### üü© **Was im Protokoll gemacht wurde:**

1Ô∏è‚É£ **Teil 2 (Peaks & Fit-Parameter)** Das Gau√ü-Fitting in Teil 2 wurde auf den **gemittelten Profilen** (also dem Durchschnitt aus je drei Replikaten) gemacht:

-   **1 Mittelwert-Kurve** f√ºr Kontrolle (CTRL)
-   **1 Mittelwert-Kurve** f√ºr RNase

‚û°Ô∏è Ziel:

-   **robuste Erkennung von Maxima und Schultern**
-   ‚Äûglobale‚Äú Fit-Parameter (Amplitude, Lage, Breite) der **Durchschnittskurve** pro Protein und Bedingung
-   diese Maxima-Positionen dienen als ‚ÄûStartpunkte‚Äú f√ºr die Fits in Teil 3

------------------------------------------------------------------------

2Ô∏è‚É£ **Teil 3 (Gaussian Fit auf Einzeldaten)** Hier wurde das **Gau√ü-Fitting f√ºr alle 6 Replikate einzeln** durchgef√ºhrt!

-   **3 Replikate f√ºr Kontrolle (ctrl1, ctrl2, ctrl3)**
-   **3 Replikate f√ºr RNase (rnase1, rnase2, rnase3)**

‚û°Ô∏è Ziel:

-   **individuelle Fit-Parameter** pro Replikat (z.B. Amplitude = Proteinmenge in diesem Peak in diesem Replikat!)
-   diese Werte werden sp√§ter (Teil 5) mit einem **t-Test** zwischen den Bedingungen (CTRL vs. RNase) verglichen.

------------------------------------------------------------------------

### üü° **Zusammengefasst:**

| Phase | Datenbasis | Ziel |
|---------------|------------------|---------------------------------------|
| **Teil 2** | Mittelwert-Kurve aus 3 Replikaten | Finden von Peaks und deren Startparameter (robust, stabil) |
| **Teil 3** | 6 Replikat-Kurven (je Protein) | Fit-Parameter (Amplitude, Position, Breite) pro Replikat ermitteln |

------------------------------------------------------------------------

‚úÖ **Also: Das finale Gau√ü-Fitting f√ºr die t-Tests wird an allen 6 Replikaten gemacht!** ‚ùå **Nicht nur auf den Mittelwerten!** ‚úÖ Aber die Mittelwert-Kurve liefert die ‚Äûguten Startwerte‚Äú, damit die Fits bei den Einzel-Replikaten stabiler sind.

------------------------------------------------------------------------

üí° **Falls du m√∂chtest**, kann ich dir das gerne auch als ‚ÄûSchema‚Äú zeichnen (z.B. Flowchart), wie das Protokoll hier abl√§uft! üöÄ
