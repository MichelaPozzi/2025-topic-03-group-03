---
title: "Exploration"
output: html_document
date: "2025-05-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
MS_Table_norm = read.table("MS_Table.norm.csv", header=TRUE, row.names=1, sep = ",")
```

# Data exploration

```{r}
Fraktionsnamen = c('Fraction1_Ctrl', 'Fraction1_RNAse', 'Fraction2_Ctrl', 'Fraction2_RNAse','Fraction3_Ctrl', 'Fraction3_RNAse','Fraction4_Ctrl', 'Fraction4_RNAse','Fraction5_Ctrl', 'Fraction5_RNAse','Fraction6_Ctrl', 'Fraction6_RNAse','Fraction7_Ctrl', 'Fraction7_RNAse','Fraction8_Ctrl', 'Fraction8_RNAse','Fraction9_Ctrl', 'Fraction9_RNAse','Fraction10_Ctrl', 'Fraction10_RNAse','Fraction11_Ctrl', 'Fraction11_RNAse','Fraction12_Ctrl', 'Fraction12_RNAse','Fraction13_Ctrl', 'Fraction13_RNAse','Fraction14_Ctrl', 'Fraction14_RNAse','Fraction15_Ctrl', 'Fraction15_RNAse','Fraction16_Ctrl', 'Fraction16_RNAse','Fraction17_Ctrl', 'Fraction17_RNAse','Fraction18_Ctrl', 'Fraction18_RNAse','Fraction19_Ctrl', 'Fraction19_RNAse','Fraction20_Ctrl', 'Fraction20_RNAse','Fraction21_Ctrl', 'Fraction21_RNAse','Fraction22_Ctrl', 'Fraction22_RNAse','Fraction23_Ctrl', 'Fraction23_RNAse','Fraction24_Ctrl', 'Fraction24_RNAse','Fraction25_Ctrl', 'Fraction25_RNAse')
```

```{r}
Proteinnamen = rownames(MS_Table)
```



```{r} 
# Subtabellen f√ºr jedes Replikat
for (i in 1:6) {

  spalten_index = seq(from = i, to = 150, by = 6) 
  teilmatrix = MS_Table_norm[, spalten_index]
  
  assign(Treatmentnamen[i], teilmatrix) # neue Subtabellen, richtig benannt
}
```

```{r}
# Mittelwerte f√ºr Treatments als Tabelle

Mittelwert_matrix = t(apply(MS_Table_norm, 1, function(row) {
  sapply(1:50, function(i) {
    spalten_index = ((i - 1) * 3 + 1):(i * 3)
    mean(row[spalten_index])
  })
}))

# Jeden zweiten Mittelwert ausw√§hlen
Mittelwerte_Kontrolle = as.data.frame(Mittelwert_matrix[, seq(1, 50, by=2)])
Mittelwerte_RNAse = as.data.frame(Mittelwert_matrix[, seq(2, 50, by=2)])

colnames(Mittelwerte_Kontrolle) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
colnames(Mittelwerte_RNAse) <- paste0(Fraktionsnamen[seq(1, 50, by=2)])
  
```


## Maxima Bestimmung
Ber√ºcksichtigt: Plateaus, gespaltene Peaks, Randmaxima, Threshold

```{r}
find_maxima = function(mat, threshold = 2) {
  result = do.call(rbind, lapply(1:nrow(mat), function(i) {
    x = mat[i, ]
    
    # Normale Maxima: zweite Ableitung mit Vorzeichenwechsel
    idx = which(diff(sign(diff(x))) == -2) + 1 
    
    # Plateaumaxima
    rle_x = rle(x)  # Run-Length-Encoding der Werte
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    plateau_idx = c()
    for (j in seq_along(values)) {
      # Nur Plateaus mit L√§nge > 1 pr√ºfen
      if (lengths[j] > 1) {
        start_pos = starts[j]
        end_pos = ends[j]
        
        # Werte links und rechts des Plateaus
        left_val = if (start_pos > 1) x[start_pos - 1] else -Inf
        right_val = if (end_pos < length(x)) x[end_pos + 1] else -Inf
        
        # Plateau ist lokales Maximum, wenn Wert >= Nachbarn
        if (values[j] >= left_val && values[j] >= right_val) {
          # Plateau-Maximum: Indize des Plateausstartpunkts
          plateau_idx = c(plateau_idx, mean(start_pos:end_pos))
        }
      }
    }
    
    # Kombination von normalen Maxima und Plateau-Maxima
    all_idx = sort(unique(c(idx, plateau_idx))) #unique: falls Werte doppelt werden sie entfernt, sort: sotieren der Indizes in aufsteigender Reihenfolge
    
    # Randmaxima pr√ºfen
    if (x[1] > x[2]) {all_idx = c(1, all_idx)}
    if (x[length(x)] > x[length(x)-1]) {all_idx = c(all_idx, length(x))}
    
    # nur Werte > threshold = 2% behalten
    all_idx = all_idx[x[all_idx] > threshold]
    
    # Peaks bereinigen: Wenn zwei Peaks nur einen Wert dazwischen haben, den kleineren entfernen
    if (length(all_idx) >= 2) {
      to_remove = c()
      for (k in 1:(length(all_idx)-1)) {
        if (all_idx[k+1] - all_idx[k] == 2) {
          # Indizes der Peaks
          peak1 = all_idx[k]
          peak2 = all_idx[k+1]
          if (x[peak1] >= x[peak2]) {
            to_remove = c(to_remove, peak2)
          } else {
            to_remove = c(to_remove, peak1)
          }
        }
      } # Entfernen des niedrigeren Wert
      if (length(to_remove) > 0) {
        all_idx = setdiff(all_idx, to_remove)
      }
    }
    
    if (length(all_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = all_idx,
        Wert = x[all_idx]
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}

# Maxima f√ºr Mittelwerte aus Triplikaten
Mittelwerte_Kontrolle_mat = as.matrix(sapply(Mittelwerte_Kontrolle, as.numeric))
Mittelwerte_RNAse_mat = as.matrix(sapply(Mittelwerte_RNAse, as.numeric))

Maxima_Mittelwerte_Kontrolle = find_maxima(Mittelwerte_Kontrolle_mat)
Maxima_Mittelwerte_RNAse = find_maxima(Mittelwerte_RNAse_mat)
```

## Schulterpunkte

```{r}
# Funktion zum Finden der Schulterpunkte
find_shoulders = function(binary_mat, Proteinnamen) {
  result = do.call(rbind, lapply(1:nrow(binary_mat), function(i) {
    x = binary_mat[i, ]
    rle_x = rle(x)
    lengths = rle_x$lengths
    values = rle_x$values
    ends = cumsum(lengths)
    starts = ends - lengths + 1
    
    schulter_idx = c()
    for (j in seq_along(values)) {
      if (values[j] == 1 && lengths[j] >= 4) {
        start_pos = starts[j]
        end_pos = ends[j]
        schulter_idx = c(schulter_idx, mean(start_pos:end_pos))
      }
    }
    
    if (length(schulter_idx) > 0) {
      data.frame(
        Protein = Proteinnamen[i],
        Zeile = i,
        Fraktion = schulter_idx
      )
    } else {
      NULL
    }
  }))
  
  rownames(result) = NULL
  return(result)
}
```


### Schulterpunkte f√ºr Kontrolle
```{r} 
#vor√ºbergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_Kontrolle = ifelse(Mittelwerte_Kontrolle > 2, 1, 0) # wenn gr√∂√üer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vor√ºbergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife √ºber alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_Kontrolle)) {
  Protein = Maxima_Mittelwerte_Kontrolle$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_Kontrolle$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen f√ºr die Spalten berechnen (Grenzen pr√ºfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_Kontrolle), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ¬±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_Kontrolle[Protein, Fraktions_bereich] = 0
}

Schulterpunkte_Kontrolle = find_shoulders(Schulter_Mittelwerte_Kontrolle, Proteinnamen)

```

### Schulterpunkte f√ºr RNAse

```{r}
#vor√ºbergehenes Entfernen von Proteinmenge die unter Threshold liegt
Schulter_Mittelwerte_RNAse = ifelse(Mittelwerte_RNAse > 2, 1, 0) # wenn gr√∂√üer als 2 dann wird es zu 1 sonst wird der Wert auf 0 gesetzt

# vor√ºbergehendes Entfernen von Bereichen um Maxima > werden auf 0 gesetzt: im Umkreis um 3 
# Schleife √ºber alle Maxima
for (i in 1:nrow(Maxima_Mittelwerte_RNAse)) {
  Protein = Maxima_Mittelwerte_RNAse$Zeile[i]      # Zeile (Protein)
  Fraktion = Maxima_Mittelwerte_RNAse$Fraktion[i]  # Spalte (Fraktion)
  
  # Bereichsgrenzen f√ºr die Spalten berechnen (Grenzen pr√ºfen!)
  Fraktions_bereich = max(1, Fraktion - 3):min(ncol(Schulter_Mittelwerte_RNAse), Fraktion + 3)
  
  # Nur in dieser Zeile (Protein) die ¬±3 Spalten auf 0 setzen
  Schulter_Mittelwerte_RNAse[Protein, Fraktions_bereich] = 0
}


Schulterpunkte_RNAse = find_shoulders(Schulter_Mittelwerte_RNAse, Proteinnamen)
```

# es gibt nicht viele Schulterpunkte bei 2,5 die frage ist nur ob wir die entfernen m√ºssen

## Zusammenf√ºhren der Werte
Ich w√ºrde das nochmal bisschen ver√§ndern aber so funktioniert es auf jeden Fall und wir haben Tabellen in denen jetzt alle Maxima & Schulerpunkte haben zum Weiterarbeiten

```{r}
# F√ºr Schulterpunkte Wert hinzuf√ºgen
Schulterpunkte_Kontrolle$Fraktion_gerundet = round(Schulterpunkte_Kontrolle$Fraktion)
Schulterpunkte_Kontrolle$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_Kontrolle[zeile, fraktion]
}, Schulterpunkte_Kontrolle$Zeile, Schulterpunkte_Kontrolle$Fraktion_gerundet)

Schulterpunkte_RNAse$Fraktion_gerundet = round(Schulterpunkte_RNAse$Fraktion)
Schulterpunkte_RNAse$Wert = mapply(function(zeile, fraktion) {
  Mittelwerte_RNAse[zeile, fraktion]
}, Schulterpunkte_RNAse$Zeile, Schulterpunkte_RNAse$Fraktion_gerundet)

# Markieren und zusammenf√ºgen Kontrolle
Maxima_Mittelwerte_Kontrolle$Typ = "Maxima"
Schulterpunkte_Kontrolle$Typ = "Schulter"

Combined_Kontrolle = rbind(
  Maxima_Mittelwerte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_Kontrolle[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_Kontrolle = Combined_Kontrolle[order(Combined_Kontrolle$Zeile, Combined_Kontrolle$Fraktion), ]

# Markieren und zusammenf√ºgen RNAse
Maxima_Mittelwerte_RNAse$Typ = "Maxima"
Schulterpunkte_RNAse$Typ = "Schulter"

Combined_RNAse = rbind(
  Maxima_Mittelwerte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")],
  Schulterpunkte_RNAse[, c("Protein", "Zeile", "Fraktion", "Wert", "Typ")]
)
Combined_RNAse = Combined_RNAse[order(Combined_RNAse$Zeile, Combined_RNAse$Fraktion), ]
```



# Vergleich von RNAse & Kontrolle
```{r}
# Bestimmung der p-Werte f√ºr die verschiedenen Maxima

# funktioniert noch nicht
# Liste deiner Replikat-Tabellen
ctrl_reps = list(Ctrl1_norm, Ctrl2_norm, Ctrl3_norm)
rnase_reps = list(RNAse1_norm, RNAse3_norm, RNAse3_norm)

# Maxima aus beiden Treatments zusammenf√ºhren
peaks_ctrl = data.frame(Protein = Combined_Kontrolle$Protein, Fraktion = Combined_Kontrolle$Fraktion, Maximum = Combined_Kontrolle$Wert)
peaks_rnase = data.frame(Protein = Combined_RNAse$Protein, Fraktion = Combined_RNAse$Fraktion, Maximum = Combined_RNAse$Wert)

# Kombinierte Peaks
combined_peaks = unique(rbind(peaks_ctrl, peaks_rnase))

# Ergebnis-Tabelle 
results = data.frame()

for (i in 1:nrow(combined_peaks)) {
  protein = combined_peaks$Protein[i]
  fraktion = as.character(combined_peaks$Fraktion[i])

  # Hole Werte aus allen 3 Kontroll-Replikaten  # ab hier Fehler 
  ctrl_vals = sapply(ctrl_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })

  # Hole Werte aus allen 3 RNase-Replikaten
  rnase_vals = sapply(rnase_reps, function(df) {
    if (protein %in% rownames(df) && fraktion %in% colnames(df)) {
      return(df[protein, fraktion])
    } else {
      return(NA)
    }
  })

  # Entferne NA-Werte
  ctrl_vals = na.omit(ctrl_vals)
  rnase_vals = na.omit(rnase_vals)

  # Wenn n√∂tig: Mini-St√∂rung hinzuf√ºgen bei identischen Werten
  if (length(ctrl_vals) >= 2 && all(abs(ctrl_vals - ctrl_vals[1]) < 1e-10)) {
    ctrl_vals[2] <- ctrl_vals[2] + 1e-6
  }
  if (length(rnase_vals) >= 2 && all(abs(rnase_vals - rnase_vals[1]) < 1e-10)) {
    rnase_vals[2] <- rnase_vals[2] + 1e-6
  }

  # t-Test nur wenn beide Gruppen mindestens 2 Werte haben
  

  if (length(ctrl_vals) >= 2 && length(rnase_vals) >= 2) {
    ftest_p <- tryCatch(var.test(ctrl_vals, rnase_vals)$p.value, error = function(e) NA)
    t_p <- tryCatch(
      t.test(ctrl_vals, rnase_vals, var.equal = (ftest_p > 0.05))$p.value,
      error = function(e) NA
    )
  } else {
    t_p <- NA
  }

  # Ergebnis speichern
  results = rbind(results, data.frame(
    Protein = protein,
    Fraktion = as.integer(fraktion),
    p_value = t_p
  ))
}

# FDR-Korrektur
results$adj_p = p.adjust(results$p_value, method = "BH")

```



```{r}
plot(1:25, Mittelwerte_Kontrolle[64,], type = "l", col = "blue",
     xlab = "Fraktion", ylab = "Intensit√§t", main = "Proteinverteilung")


# plot(1:25, RNAse1_norm[58,], type = "l", col = "blue",
    # xlab = "Fraktion", ylab = "Intensit√§t", main = "Proteinverteilung")

```




















## Jettes Plan
- Funktionen erstellen f√ºr verschiedene anzahl an peaks (gucken, wie viele es generell gibt) mit Parametern Mittelwert, Standardabweichung, Amplitude, die Fehlerberechnung beinhalten und somit f√ºr jedes Protein f√ºr die jeweilige Verteilung optimiert werden k√∂nnen
- mit der optimierung f√ºr jedes Protein (noch bei den Mittelwerten der replikate) die passenden Parameter erhalten
- also optimierung f√ºr jeden der drei parameter und f√ºr jedes Treatment
- optimierte parameter abspeichern als vektor
- danach erst Gau√ü fit f√ºr jedes Replikat durchf√ºhren

https://chatgpt.com/share/683b2417-6030-8006-b6d2-479f6f34f641

------------------------------------------------------------------------

### üü© **Was im Protokoll gemacht wurde:**

1Ô∏è‚É£ **Teil 2 (Peaks & Fit-Parameter)** Das Gau√ü-Fitting in Teil 2 wurde auf den **gemittelten Profilen** (also dem Durchschnitt aus je drei Replikaten) gemacht:

-   **1 Mittelwert-Kurve** f√ºr Kontrolle (CTRL)
-   **1 Mittelwert-Kurve** f√ºr RNase

‚û°Ô∏è Ziel:

-   **robuste Erkennung von Maxima und Schultern**
-   ‚Äûglobale‚Äú Fit-Parameter (Amplitude, Lage, Breite) der **Durchschnittskurve** pro Protein und Bedingung
-   diese Maxima-Positionen dienen als ‚ÄûStartpunkte‚Äú f√ºr die Fits in Teil 3

------------------------------------------------------------------------

2Ô∏è‚É£ **Teil 3 (Gaussian Fit auf Einzeldaten)** Hier wurde das **Gau√ü-Fitting f√ºr alle 6 Replikate einzeln** durchgef√ºhrt!

-   **3 Replikate f√ºr Kontrolle (ctrl1, ctrl2, ctrl3)**
-   **3 Replikate f√ºr RNase (rnase1, rnase2, rnase3)**

‚û°Ô∏è Ziel:

-   **individuelle Fit-Parameter** pro Replikat (z.B. Amplitude = Proteinmenge in diesem Peak in diesem Replikat!)
-   diese Werte werden sp√§ter (Teil 5) mit einem **t-Test** zwischen den Bedingungen (CTRL vs. RNase) verglichen.

------------------------------------------------------------------------

### üü° **Zusammengefasst:**

| Phase | Datenbasis | Ziel |
|---------------|------------------|---------------------------------------|
| **Teil 2** | Mittelwert-Kurve aus 3 Replikaten | Finden von Peaks und deren Startparameter (robust, stabil) |
| **Teil 3** | 6 Replikat-Kurven (je Protein) | Fit-Parameter (Amplitude, Position, Breite) pro Replikat ermitteln |

------------------------------------------------------------------------

‚úÖ **Also: Das finale Gau√ü-Fitting f√ºr die t-Tests wird an allen 6 Replikaten gemacht!** ‚ùå **Nicht nur auf den Mittelwerten!** ‚úÖ Aber die Mittelwert-Kurve liefert die ‚Äûguten Startwerte‚Äú, damit die Fits bei den Einzel-Replikaten stabiler sind.

------------------------------------------------------------------------

üí° **Falls du m√∂chtest**, kann ich dir das gerne auch als ‚ÄûSchema‚Äú zeichnen (z.B. Flowchart), wie das Protokoll hier abl√§uft! üöÄ
