---
title: "Untitled"
output: html_document
date: "2025-06-19"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
MS_Table_norm = read.table("Datensätze/MS_Table.norm.csv", header=TRUE, row.names=1, sep = ",")
```

### Einlesen von Table_RBPs
```{r}
# 1. Datei komplett als Text einlesen
raw <- readLines("Datensätze/Table_HS_RBP.txt")

# 2. Ab Zeile 7 extrahieren (Header + Daten)
raw_data <- raw[7:length(raw)]

# 3. Entferne alle \" (Backslash-Anführungszeichen)
clean_data <- gsub('\\"', '', raw_data)

# 4. Schreibe die bereinigten Zeilen in eine temporäre Datei
writeLines(clean_data, "cleaned_table.txt")

# 5. Lese die bereinigte Datei als richtige Tabelle ein
Table_HS_RBP = read.delim("cleaned_table.txt",
                    sep = "\t",
                    header = TRUE,
                    stringsAsFactors = FALSE,
                    check.names = FALSE)

```

### Einlesen von Table_NO-RBPs
```{r}
# 1. Datei komplett als Text einlesen
raw <- readLines("Datensätze/Table_HS_Non_RBP.txt")

# 2. Ab Zeile 7 extrahieren (Header + Daten)
raw_data <- raw[7:length(raw)]

# 3. Entferne alle \" (Backslash-Anführungszeichen)
clean_data <- gsub('\\"', '', raw_data)

# 4. Schreibe die bereinigten Zeilen in eine temporäre Datei
writeLines(clean_data, "cleaned_table.txt")

# 5. Lese die bereinigte Datei als richtige Tabelle ein
Table_HS_NO_RBP = read.delim("cleaned_table.txt",
                    sep = "\t",
                    header = TRUE,
                    stringsAsFactors = FALSE,
                    check.names = FALSE)

```


```{r}
# Vergleich wie viele in den beiden Tabellen sind -> brauchen wir eigentlich eh nicht mehr

# gemeinsam = intersect(Table_HS_RBP$Entry_Name, rownames(MS_Table_norm))
# gemeinsam # welche sind das 
# length(gemeinsam) # wie viele sind gleich


# Extra Tabelle mit nur denen die wir auch haben
RBP_Table = Table_HS_RBP[Table_HS_RBP$Entry_Name %in% rownames(MS_Table_norm), ]

```

```{r}
# Vergleich wie viele in den beiden Tabellen sind -> brauchen wir eigentlich eh nicht mehr

# gemeinsam = intersect(Table_HS_NO_RBP$Entry_Name, rownames(MS_Table_norm))
# gemeinsam # welche sind das 
# length(gemeinsam) # wie viele sind gleich


# Extra Tabelle mit nur denen die wir auch haben
No_RBP_Table = Table_HS_NO_RBP[Table_HS_NO_RBP$Entry_Name %in% rownames(MS_Table_norm), ]

```


```{r}
# 1. Alle Spaltennamen aus der RBP-Tabelle
rbp_cols <- colnames(Table_HS_RBP)

# 2. Welche Spalten davon existieren in der NO_RBP-Tabelle?
existing_no_rbp_cols <- intersect(rbp_cols, colnames(Table_HS_NO_RBP))

# 3. Erzeuge NO_RBP-Tabelle mit gleichen Spalten, fehlende füllen wir mit NA
No_RBP_Table_aligned <- Table_HS_NO_RBP[, existing_no_rbp_cols]

# 4. Füge die fehlenden Spalten mit NA hinzu
missing_cols <- setdiff(rbp_cols, existing_no_rbp_cols)
for (col in missing_cols) {
  No_RBP_Table_aligned[[col]] <- NA
}

# 5. Bringe die Spalten in dieselbe Reihenfolge wie in RBP-Tabelle
No_RBP_Table_aligned <- No_RBP_Table_aligned[, rbp_cols]

# 6. Füge eine Kategorie-Spalte hinzu
Table_HS_RBP$Kategorie <- "RBP"
No_RBP_Table_aligned$Kategorie <- "NO_RBP"

# 7. Gleiche Einträge wie in MS_Table_norm behalten
RBP_Table <- Table_HS_RBP[Table_HS_RBP$Entry_Name %in% rownames(MS_Table_norm), ]
No_RBP_Table <- No_RBP_Table_aligned[No_RBP_Table_aligned$Entry_Name %in% rownames(MS_Table_norm), ]

# 8. Vereinige die beiden Tabellen
combined_table <- rbind(RBP_Table, No_RBP_Table)

```



```{r}
# Tabelle von denen die wir auch als shift klassifiziert haben
shift_ids = df_ergebnisse$Protein[df_ergebnisse$Shift_Kategorie != "kein_shift"]
Proteine_erkannt = RBP_Table[RBP_Table$Entry_Name %in% shift_ids, ]


```



# Lineare Regression


## für alle im Datensatz die gemessen wurden sind
```{r}
# Lineares Modell fitten
modell <- lm(RBP2GO_Score ~ Mass_kDa, data = RBP_Table)

# Zusammenfassung des Modells anzeigen
summary(modell)

```

```{r}
modell_multi <- lm(RBP2GO_Score ~ Mass_kDa + Length_AA, data = RBP_Table)
summary(modell_multi)

```



## für unsere erkannten Proteine
```{r}
# Lineares Modell fitten
modell <- lm(RBP2GO_Score ~ Mass_kDa, data = Proteine_erkannt)

# Zusammenfassung des Modells anzeigen
summary(modell)

```

```{r}
modell_multi <- lm(RBP2GO_Score ~ Mass_kDa + Length_AA + pI, data = Proteine_erkannt)
summary(modell_multi)

```

# Lineare Regression: Aussage über Masse,Länge, pI über shift_score
```{r}
# physikalische Eigenschaften der Proteine, die übereinstimmen (RBP_Table), in df ergebnisse hinzufügen für die Regression
phys_eigenschaften = RBP_Table[, c("Entry_Name", "Mass_kDa", "Length_AA", "pI")]

df_ergenisse_phys = merge(df_ergebnisse, phys_eigenschaften, 
                   by.x = "Protein", 
                   by.y = "Entry_Name", all = FALSE)
```

```{r}
# Regression mit den physikalischen Eigenschaften bezogen auf den von uns bestimmten shift_score
model = lm(Shift_Score ~ Mass_kDa + Length_AA + pI, data = df_ergenisse_phys)
summary(model)
# Modell hat keinen guten R2 Wert also sind die 3 eigenschaften nicht perfekt, um den score vorauszusagen
```

```{r}
df_ergenisse_phys$fitted_shift = predict(model, newdata = df_ergenisse_phys)
```


```{r}
plot(df_ergenisse_phys$Shift_Score, df_ergenisse_phys$fitted_shift,
     xlab = "Gemessener Shift Score",
     ylab = "Vorhergesagter (fitted) Shift Score",
     main = "Vergleich gemessener vs. vorhergesagter Shift Scores")
abline(a=0, b=1, col="red")  # ideale Gerade y=x
# gemessener und vorausgesagter shift stimmen nicht wirklch überein - Info über die eigenschaften reicht eigentlich nicht aus, um shift_score zu bestimmen
```

```{r}
# Variablen auswählen und fehlende Werte entfernen
vars = c("Mass_kDa", "Length_AA", "pI", "fitted_shift")
df_clust = df_ergenisse_phys[complete.cases(df_ergenisse_phys[, vars]), ]

# Clustering vorbereiten (Skalierung wichtig!)
scaled_data = scale(df_clust[, vars])

# K-Means Clustering 
set.seed(42)  # für Reproduzierbarkeit
kmeans_result = kmeans(scaled_data, centers = 5)

# Cluster-Zuweisung speichern
df_clust$regression_cluster = factor(kmeans_result$cluster)
```


```{r}
# Ergebnisse der Regression clustern
# PCA durchführen
pca = prcomp(scaled_data, scale. = FALSE)  

# Daten für Plot
plot_df = data.frame(PC1 = pca$x[,1],
                      PC2 = pca$x[,2],
                      Cluster = df_clust$regression_cluster)

# Plot
library(ggplot2)

ggplot(plot_df, aes(x = PC1, y = PC2, color = Cluster)) +
  geom_point(size = 2, alpha = 0.7) +
  theme_minimal() +
  labs(title = "Cluster auf Basis von Regression + Eigenschaften",
       x = paste0("PC1 (", round(summary(pca)$importance[2,1]*100,1), "%)"),
       y = paste0("PC2 (", round(summary(pca)$importance[2,2]*100,1), "%)")) +
  scale_color_brewer(palette = "Set2")
```

