---
title: "Untitled"
output: html_document
date: "2025-06-19"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
MS_Table_norm = read.table("Datensätze/MS_Table.norm.csv", header=TRUE, row.names=1, sep = ",")
```

### Einlesen von Table_RBPs
```{r}
# 1. Datei komplett als Text einlesen
raw <- readLines("Datensätze/Table_HS_RBP.txt")

# 2. Ab Zeile 7 extrahieren (Header + Daten)
raw_data <- raw[7:length(raw)]

# 3. Entferne alle \" (Backslash-Anführungszeichen)
clean_data <- gsub('\\"', '', raw_data)

# 4. Schreibe die bereinigten Zeilen in eine temporäre Datei
writeLines(clean_data, "cleaned_table.txt")

# 5. Lese die bereinigte Datei als richtige Tabelle ein
Table_HS_RBP = read.delim("cleaned_table.txt",
                    sep = "\t",
                    header = TRUE,
                    stringsAsFactors = FALSE,
                    check.names = FALSE)

```

### Einlesen von Table_NO-RBPs
```{r}
# 1. Datei komplett als Text einlesen
raw <- readLines("Datensätze/Table_HS_Non_RBP.txt")

# 2. Ab Zeile 7 extrahieren (Header + Daten)
raw_data <- raw[7:length(raw)]

# 3. Entferne alle \" (Backslash-Anführungszeichen)
clean_data <- gsub('\\"', '', raw_data)

# 4. Schreibe die bereinigten Zeilen in eine temporäre Datei
writeLines(clean_data, "cleaned_table.txt")

# 5. Lese die bereinigte Datei als richtige Tabelle ein
Table_HS_NO_RBP = read.delim("cleaned_table.txt",
                    sep = "\t",
                    header = TRUE,
                    stringsAsFactors = FALSE,
                    check.names = FALSE)

```


```{r}
# Vergleich wie viele in den beiden Tabellen sind -> brauchen wir eigentlich eh nicht mehr

# gemeinsam = intersect(Table_HS_RBP$Entry_Name, rownames(MS_Table_norm))
# gemeinsam # welche sind das 
# length(gemeinsam) # wie viele sind gleich


# Extra Tabelle mit nur denen die wir auch haben
RBP_Table = Table_HS_RBP[Table_HS_RBP$Entry_Name %in% rownames(MS_Table_norm), ]

```

```{r}
# Vergleich wie viele in den beiden Tabellen sind -> brauchen wir eigentlich eh nicht mehr

# gemeinsam = intersect(Table_HS_NO_RBP$Entry_Name, rownames(MS_Table_norm))
# gemeinsam # welche sind das 
# length(gemeinsam) # wie viele sind gleich


# Extra Tabelle mit nur denen die wir auch haben
No_RBP_Table = Table_HS_NO_RBP[Table_HS_NO_RBP$Entry_Name %in% rownames(MS_Table_norm), ]

```


```{r}
# 1. Alle Spaltennamen aus der RBP-Tabelle
rbp_cols <- colnames(Table_HS_RBP)

# 2. Welche Spalten davon existieren in der NO_RBP-Tabelle?
existing_no_rbp_cols <- intersect(rbp_cols, colnames(Table_HS_NO_RBP))

# 3. Erzeuge NO_RBP-Tabelle mit gleichen Spalten, fehlende füllen wir mit NA
No_RBP_Table_aligned <- Table_HS_NO_RBP[, existing_no_rbp_cols]

# 4. Füge die fehlenden Spalten mit NA hinzu
missing_cols <- setdiff(rbp_cols, existing_no_rbp_cols)
for (col in missing_cols) {
  No_RBP_Table_aligned[[col]] <- NA
}

# 5. Bringe die Spalten in dieselbe Reihenfolge wie in RBP-Tabelle
No_RBP_Table_aligned <- No_RBP_Table_aligned[, rbp_cols]

# 6. Füge eine Kategorie-Spalte hinzu
Table_HS_RBP$Kategorie <- "RBP"
No_RBP_Table_aligned$Kategorie <- "NO_RBP"

# 7. Gleiche Einträge wie in MS_Table_norm behalten
RBP_Table <- Table_HS_RBP[Table_HS_RBP$Entry_Name %in% rownames(MS_Table_norm), ]
No_RBP_Table <- No_RBP_Table_aligned[No_RBP_Table_aligned$Entry_Name %in% rownames(MS_Table_norm), ]

# 8. Vereinige die beiden Tabellen
combined_table <- rbind(RBP_Table, No_RBP_Table)

```


```{r}
library(readr)
library(dplyr)

df_uniprot <- read_tsv("Datensätze/Uniprot_infos2.tsv", comment = "#", quote = "")

df_uniprot_counts <- df_uniprot %>%
  mutate(
    Zinc_Count      = ifelse(is.na(`Zinc finger`)      | `Zinc finger` == "",      NA, lengths(strsplit(`Zinc finger`, ";\\s*"))),
    Coil_Count      = ifelse(is.na(`Coiled coil`)      | `Coiled coil` == "",      NA, lengths(strsplit(`Coiled coil`, ";\\s*"))),
    Signal_Count    = ifelse(is.na(`Signal peptide`)   | `Signal peptide` == "",   NA, lengths(strsplit(`Signal peptide`, ";\\s*"))),
    Glyco_Count     = ifelse(is.na(`Glycosylation`)    | `Glycosylation` == "",    NA, lengths(strsplit(`Glycosylation`, ";\\s*"))),
    Disulfide_Count = ifelse(is.na(`Disulfide bond`)   | `Disulfide bond` == "",   NA, lengths(strsplit(`Disulfide bond`, ";\\s*"))),
    TM_Count        = ifelse(is.na(`Transmembrane`)    | `Transmembrane` == "",    NA, lengths(strsplit(`Transmembrane`, ";\\s*")))
  ) %>%
  select(Entry, `Entry Name`, Zinc_Count, Coil_Count, TM_Count)

combined_table <- combined_table %>%
  left_join(df_uniprot_counts, by = c("Entry_Name" = "Entry Name"))
```



# Lineare Regression: Isoelektrischer Punkt und Masse als Prädiktoren für den Shift_Score

```{r}
# physikalische Eigenschaften der Proteine, die übereinstimmen (RBP_Table), in df ergebnisse hinzufügen für die Regression
phys_eigenschaften = combined_table[, c("Entry_Name", "Mass_kDa", "Length_AA", "pI", "Listing_Count","Zinc_Count", "Coil_Count", "RBP2GO_Score", "TM_Count")]


df_ergebnisse_phys = merge(df_ergebnisse, phys_eigenschaften,
                   by.x = "Protein", 
                   by.y = "Entry_Name", all = FALSE)

df_ergebnisse_phys$RBP_Status = ifelse(df_ergebnisse_phys$Listing_Count >= 5, "RBP", "NO_RBP")

#Einteilung der Proteine ein RBP/ kein RBP auf Basis des SHift_Scores
df_ergebnisse_phys$RBP_nach_Score <- ifelse(df_ergebnisse_phys$Shift_Kategorie == "kein_shift", "NO_RBP", "RBP")
df_ergebnisse_phys$RBP_nach_Score <- factor(df_ergebnisse_phys$RBP_nach_Score, levels = c("NO_RBP", "RBP"))
```

```{r}
# Regression mit den physikalischen Eigenschaften bezogen auf den von uns bestimmten shift_score
model_linear = lm(Shift_Score ~ pI + Mass_kDa, data = df_ergebnisse_phys)
summary(model_linear)
```
```{r}
# Visualisierung der linearen Regressionsergebnissen: Shift Score durch pI und Masse
df_plot <- df_ergebnisse_phys[complete.cases(df_ergebnisse_phys[, c("RBP_nach_Score", "Mass_kDa", "pI")]), ]
df_plot <- df_plot[df_plot$Mass_kDa < 2000, ]
df_plot$predicted_score <- predict(model_linear, newdata = df_plot, type = "response")

ggplot(df_plot, aes(x = Mass_kDa, y = pI, color = predicted_score)) +
  geom_point(size = 2, alpha = 0.7) +
  scale_color_gradient(low = "blue", high = "red") +
  labs(title = "Vorhergesagter Score auf Basis von pI und Masse",
       x = "Masse", y = "Isoelektrischer Punkt (pI)",
       color = "Score") +
  theme_minimal()
```
```{r}
# Dichteverteilungen
ggplot(df_ergebnisse_phys, aes(x = Mass_kDa, y = pI)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~RBP_nach_Score) +
  labs(x = "Masse", y = "pI", title = "2D-Dichte von Masse & pI nach Shift Kategorie") +
  theme_minimal()
```

```{r}
df_plot <- df_ergebnisse_phys[complete.cases(df_ergebnisse_phys[, c("Shift_Score", "pI", "Mass_kDa", "Shift_Kategorie")]), ]

df_plot <- df_plot[df_plot$Mass_kDa < 2000, ] # Ausreißer entfenen

# Modellvorhersage (Vorhersage des Shift Scores)
df_plot$predicted_score <- predict(model_linear, newdata = df_plot)

library(ggplot2)

ggplot(df_plot, aes(x = Mass_kDa, y = pI, color = Shift_Kategorie)) +
  geom_point(size = 2, alpha = 0.8) +
  labs(title = "Shift-Kategorie nach Masse und pI",
       x = "Masse (kDa)", y = "Isoelektrischer Punkt (pI)",
       color = "Shift-Kategorie") +
  theme_minimal()

```
```{r}
# pI und Masse isoliert betrachten als Prädiktor für den Shift Score
# Zusammenhang zwischen Veränderung von pI bzw. Masse und dem shift score
# Fläche ist 95% Konfidenzintervall

install.packages("effects")
library(effects)

plot(allEffects(model_linear), main = "Teil-Effekte der Prädiktoren auf Shift Score")

```
```{r}
# Plots, die zeigen, dass es einen linearen Zusammenhang gibt zwischen jeweils pI/ Masse und Shift Score, das aber nicht die Variablen sind, die den Shift Score komplett erklären
ggplot(df_plot, aes(x = pI, y = Shift_Score, color = Shift_Kategorie)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  labs(title = "Einfluss von pI auf Shift Score",
       x = "Isoelektrischer Punkt (pI)",
       y = "Shift Score") +
  theme_minimal()
ggplot(df_plot, aes(x = Mass_kDa, y = Shift_Score, color = Shift_Kategorie)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, color = "black") +
  labs(title = "Einfluss von Masse auf Shift Score",
       x = "Masse (kDa)",
       y = "Shift Score") +
  theme_minimal()
```



```{#r}
model = lm(Shift_Score ~ Zinc_Count, data = df_ergebnisse_phys)
summary(model)
```


```{r}
df_ergebnisse_phys$fitted_shift = predict(model_linear, newdata = df_ergebnisse_phys)
```

```{r}
summary(df_ergebnisse_phys$fitted_shift)
range(df_ergebnisse_phys$fitted_shift, na.rm = TRUE)
```


```{r}
# Vergleich vorrherrgesagter Score durch das Modell und dem bestimmten Shift_Score
# gibt linearen Zusammenhang, aber viel Streuung
# Prädiktoren aus dem Modell allein erklären den Shift nicht

plot(df_ergebnisse_phys$Shift_Score, df_ergebnisse_phys$fittet_shift,
     xlab = "Gemessener Shift Score",
     ylab = "Vorhergesagter (fitted) Shift Score",
     main = "Vergleich gemessener vs. vorhergesagter Shift Scores")
abline(a=0, b=1, col="red")  # ideale Gerade y=x
# gemessener und vorausgesagter shift stimmen nicht wirklch überein - Info über die eigenschaften reicht eigentlich nicht aus, um shift_score zu bestimmen

plot(df_ergebnisse_phys$Shift_Score, df_ergebnisse_phys$fitted_shift,
     xlab = "Gemessener Shift Score", ylab = "Vorhergesagter Shift Score",
     main = "Vergleich gemessener vs. vorhergesagter Shift Scores")
abline(a=0, b=1, col="red")

```

```{r}
# Variablen auswählen und fehlende Werte entfernen
vars = c("Mass_kDa", "pI", "Shift_Score")
df_clust = df_ergebnisse_phys[complete.cases(df_ergebnisse_phys[, vars]), ]

# Clustering vorbereiten (Skalierung wichtig!)
scaled_data = scale(df_clust[, vars])

# K-Means Clustering 
set.seed(42)  # für Reproduzierbarkeit
kmeans_result = kmeans(scaled_data, centers = 5)

# Cluster-Zuweisung speichern
df_clust$regression_cluster = factor(kmeans_result$cluster)

```


```{r}
# Ergebnisse der Regression clustern
# PCA durchführen
pca = prcomp(scaled_data, scale. = FALSE)  

# Daten für Plot
plot_df = data.frame(PC1 = pca$x[,1],
                      PC2 = pca$x[,2],
                      Cluster = df_clust$regression_cluster)


# Plot
library(ggplot2)

ggplot(plot_df, aes(x = PC1, y = PC2, color = Cluster)) +
  geom_point(size = 2, alpha = 0.7) +
  theme_minimal() +
  labs(title = "Cluster auf Basis von Regression + Eigenschaften",
       x = paste0("PC1 (", round(summary(pca)$importance[2,1]*100,1), "%)"),
       y = paste0("PC2 (", round(summary(pca)$importance[2,2]*100,1), "%)")) +
  scale_color_brewer(palette = "Set2")


```

```{r}
outlier_index <- which.max(abs(plot_df$PC2))  # oder PC2, je nachdem
df_clust_no_outlier <- df_clust[-outlier_index, ]
scaled_data_no_outlier <- scale(df_clust_no_outlier[, vars])
set.seed(42)
kmeans_result <- kmeans(scaled_data_no_outlier, centers = 4)

# Clusterzuweisung speichern
df_clust_no_outlier$regression_cluster <- factor(kmeans_result$cluster)
pca_no_outlier <- prcomp(scaled_data_no_outlier, scale. = FALSE)

plot_df_clean <- data.frame(
  PC1 = pca_no_outlier$x[,1],
  PC2 = pca_no_outlier$x[,2],
  Cluster = df_clust_no_outlier$regression_cluster,
  Protein = df_clust_no_outlier$Protein  # falls du Protein später brauchst
)

# Mergen der Shift-Kategorie über den Proteinnamen
plot_df_clean <- merge(plot_df_clean,
                       df_ergebnisse_phys[, c("Protein", "Shift_Kategorie")],
                       by = "Protein", all.x = TRUE)


library(ggplot2)

ggplot(plot_df_clean, aes(x = PC1, y = PC2, color = Cluster)) +
  geom_point(size = 2, alpha = 0.8) +
  theme_minimal() +
  labs(title = "Cluster ohne Ausreißer im PCA-Raum")
# Falls noch nicht installiert:
# install.packages("cluster")
library(cluster)
# Distanzmatrix berechnen auf den skalierten Daten ohne Ausreißer
dists <- dist(scaled_data_no_outlier)

# Silhouette berechnen mit K-Means-Zuweisungen
sil <- silhouette(as.numeric(df_clust_no_outlier$regression_cluster), dists)
plot(sil, main = "Silhouette-Plot für K-Means-Clustering (k = 6)", col = 2:7, border = NA)
```
```{r}
# welche Shift Kategorie ist pro Cluster am häufigsten
library(dplyr)

summary_per_cluster <- df_clust_no_outlier %>%
  group_by(regression_cluster, Shift_Kategorie) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(desc(n))

#relativ:
summary_per_cluster_rel <- summary_per_cluster %>%
  group_by(regression_cluster) %>%
  mutate(
    Anteil = n / sum(n)
  ) %>%
  ungroup()

# in welchem cluster kommen mehr RBP vor 
summary_per_cluster_RBP <- df_clust_no_outlier %>%
  group_by(regression_cluster, RBP_nach_Score) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(desc(n))
summary_per_cluster_rel_RBP <- summary_per_cluster %>%
  group_by(regression_cluster) %>%
  mutate(
    Anteil = n / sum(n)
  ) %>%
  ungroup()
# statistisch überprüfen, ob sich cluster in shift Kategorie unterscheiden
# Kontingenztabelle erstellen
table_shift_cluster <- table(df_clust_no_outlier$regression_cluster, df_clust_no_outlier$Shift_Kategorie)

# Chi²-Test
chisq.test(table_shift_cluster)
# Verteilung der shift Kategorien unterscheidet sich signifikant zwischen den Clustern 

# für RBP verteilt in den Clustern:
# ebenfalls signifikant
table_shift_cluster_RBP <- table(df_clust_no_outlier$regression_cluster, df_clust_no_outlier$RBP_nach_Score)
chisq.test(table_shift_cluster_RBP)
```
```{r}
ggplot(plot_df_clean, aes(x = PC1, y = PC2, color = Shift_Kategorie)) +
  geom_point(alpha = 0.7, size = 2) +
  labs(title = "PCA: Proteine nach Shift-Kategorie eingefärbt") +
  theme_minimal()

```
```{r}
ggplot(df_clust_no_outlier, aes(x = Shift_Kategorie, y = pI, fill = Shift_Kategorie)) +
  geom_boxplot() +
  facet_wrap(~ regression_cluster) +
  theme_minimal() +
  labs(title = "pI-Werte pro Shift-Kategorie in jedem Cluster")
```
```{r}
#???
# Nur zwei Cluster vergleichen
subtable <- df_clust_no_outlier %>%
  filter(regression_cluster %in% c(2, 3)) %>%
  count(regression_cluster, Shift_Kategorie) %>%
  tidyr::pivot_wider(names_from = Shift_Kategorie, values_from = n, values_fill = 0)

chisq.test(subtable[,-1])

```
```{r}
# left shift Proteine klar abgegrent in Clusteranalyse
# nur betrachten von left shift proteinen und eventuell weitere Analyse
df_left_shift <- df_ergebnisse_phys %>% 
  filter(Shift_Kategorie %in% c("starker_left_shift", "moderater_left_shift"))
model_left_shift <- lm(Shift_Score ~ Zinc_Count, data = df_left_shift)
summary(model_left_shift)

```

```{r}
ggplot(plot_df_clean, aes(x = PC1, y = PC2, color = Shift_Kategorie)) +
  stat_ellipse(aes(group = Shift_Kategorie), type = "norm", linetype = "dashed") +
  geom_point(aes(color = Shift_Kategorie), size = 2, alpha = 0.6) +
  theme_minimal(base_size = 13) +
  labs(
    title = "Shift-Kategorien im PCA-Raum",
    subtitle = "Umrisse zeigen die Gruppierung nach Shift-Kategorie",
    x = paste0("PC1 (", round(summary(pca_no_outlier)$importance[2,1]*100,1), "%)"),
    y = paste0("PC2 (", round(summary(pca_no_outlier)$importance[2,2]*100,1), "%)")
  ) +
  scale_color_brewer(palette = "Dark2")

```
```{r}
ggplot(plot_df_clean, aes(x = PC1, y = PC2)) +
  stat_ellipse(aes(group = Shift_Kategorie, color = Shift_Kategorie), type = "norm", linetype = "dashed") +
  geom_point(aes(color = Cluster), size = 2.5, alpha = 0.7) +
  theme_minimal(base_size = 13) +
  labs(
    title = "Physikalisch getriebene Cluster mit biologischer Shift-Kategorie als Ellipse",
    x = paste0("PC1 (", round(summary(pca_no_outlier)$importance[2,1]*100,1), "%)"),
    y = paste0("PC2 (", round(summary(pca_no_outlier)$importance[2,2]*100,1), "%)")
  ) +
  scale_color_brewer(palette = "Set2")

```


```{r}
library(ggplot2)

ggplot(df_clust, aes(x = Shift_Kategorie, y = pI)) +
  geom_violin(fill = "skyblue", alpha = 0.4) +
  geom_boxplot(width = 0.2, outlier.shape = NA) +
  theme_minimal() +
  labs(title = "pI nach Shift-Kategorie", x = "Shift-Kategorie", y = "pI")

```

```{r}
library(ggplot2)

ggplot(df_clust, aes(x = Shift_Kategorie, y = Mass_kDa)) +
  geom_violin(fill = "skyblue", alpha = 0.4) +
  geom_boxplot(width = 0.2, outlier.shape = NA) +
  theme_minimal() +
  labs(title = "Masse nach Shift-Kategorie", x = "Shift-Kategorie", y = "Masse")

```

```{r}
library(ggplot2)
library(dplyr)

# PCA Ergebnis-Datenframe erstellen
plot_df <- data.frame(
  PC1 = pca$x[,1],
  PC2 = pca$x[,2]
)

# Cluster- und Kategorie-Info aus df_clust hinzufügen
plot_df <- plot_df %>%
  mutate(
    Cluster = df_clust$regression_cluster,
    Shift_Kategorie = df_clust$Shift_Kategorie
  )

# PCA Plot mit Farbe = Shift_Kategorie und Form = Cluster
ggplot(plot_df, aes(x = PC1, y = PC2, color = Shift_Kategorie, shape = as.factor(Cluster))) +
  geom_point(size = 3, alpha = 0.8) +
  theme_minimal() +
  labs(title = "PCA: Shift_Kategorie (Farbe) & Regression Cluster (Form)",
       x = paste0("PC1 (", round(summary(pca)$importance[2,1]*100, 1), "%)"),
       y = paste0("PC2 (", round(summary(pca)$importance[2,2]*100, 1), "%)")) +
  scale_color_brewer(palette = "Set1") +
  guides(shape = guide_legend(title = "Cluster"))
```

```{r}
# Tests für Zusammenhang zwischen pI + Zinc_Cont und Kategorisierung in RBP/ nicht RBP

shapiro.test(df_ergebnisse_phys$pI[df_ergebnisse_phys$RBP_nach_Score == "RBP"]) # NV kann. angenommen werden

# Wenn Verteilung normal (z.B. geprüft mit Shapiro-Wilk-Test):
t.test(pI + Zinc_Count ~ RBP_nach_Score, data = df_ergebnisse_phys)
```

```{r}
ggplot(df_ergebnisse_phys, aes(x = pI, fill = RBP_nach_Score)) +
  geom_density(alpha = 0.5) +
  theme_minimal() +
  labs(title = "pI-Verteilung bei RBP und Nicht-RBP", x = "pI", y = "Dichte")
```

```{r}
install.packages('pROC')
library(pROC)

roc_result <- roc(df_ergebnisse_phys$RBP_nach_Score, df_ergebnisse_phys$pI)
plot(roc_result, col = "blue")
auc(roc_result)

```

```{r}
# Vergleich Kategorisierung nach Shift_Score vs. nach Datenbank
conf_matrix = table(df_ergebnisse_phys$RBP_Status, df_ergebnisse_phys$RBP_nach_Score)
colnames(conf_matrix) <- c("Vorhergesagt_NO_RBP", "Vorhergesagt_RBP")
rownames(conf_matrix) <- c("Tatsächlich_NO_RBP", "Tatsächlich_RBP")
conf_matrix

TN <- 4578
FP <- 800
FN <- 985
TP <- 697

# Funktion zur Berechnung der Klassifikationsmetriken
calc_metrics <- function(TP, TN, FP, FN) {
  Gesamttrefferquote <- (TP + TN) / (TP + TN + FP + FN)
  PPW <- TP / (TP + FP)
  Sensitivität <- TP / (TP + FN)  # Sensitivität
  Spezifität <- TN / (TN + FP)
  f1_score <- 2 * (PPW * Sensitivität) / (PPW + Sensitivität)
  
  # Ergebnisse als Dataframe
  metrics_df <- data.frame(
    Metric = c("Gesamttrefferquote", "PPW", "Sensitivität", "Spezifität", "F1-Score"),
    Value = c(Gesamttrefferquote, PPW, Sensitivität, Spezifität, f1_score)
  )
  return(metrics_df)
}

Testwerte <- calc_metrics(TP, TN, FP, FN)

# Ausgabe
print(Testwerte)

image(
  t(apply(conf_matrix, 2, rev)),           # Matrix drehen für korrektes Layout
  axes = FALSE, col = heat.colors(10),
  main = "Konfusionsmatrix (Heatmap)"
)
axis(1, at = c(0, 1), labels = colnames(conf_matrix))
axis(2, at = c(0, 1), labels = rev(rownames(conf_matrix)))

```

# Logistische Regression mit biologischen Eigenschaften in Bezug auf RBP/ NO_RBP
```{r}
# Zielvariable als Faktor (0/1-artig)
df_ergebnisse_phys$RBP_nach_Score = factor(df_ergebnisse_phys$RBP_nach_Score, levels = c("NO_RBP", "RBP"))

# Logistische Regression für Masse, Länge, pI
model_logit = glm(RBP_nach_Score ~ Zinc_Count + pI,
                   data = df_ergebnisse_phys,
                   family = "binomial")
summary(model_logit)


df_pred <- df_ergebnisse_phys[complete.cases(df_ergebnisse_phys[, c("Zinc_Count", "pI")]), ]
df_pred$fitted_Status <- predict(model_logit, newdata = df_pred, type = "response")



```

```{r}
# Wie gut stimmt das Modell mit der Klassifikation als RBP/ NO_RBP überein -> statistisch überprüfen
df_pred$fitted_Status <- ifelse(df_pred$fitted_Status > 0.5, "RBP", "NO_RBP")
df_pred$fitted_Status <- factor(df_pred$fitted_Status, levels = c("NO_RBP", "RBP"))
complete_idx <- complete.cases(df_ergebnisse_phys[, c("Zinc_Count", "pI")]) # Nur die Reihen ohne NA Werte 
df_complete <- df_ergebnisse_phys[complete_idx, ] # als Datenframe

# Vorhersagen durch das logistische Modell
df_complete$fitted_Status <- predict(model_logit, newdata = df_complete, type = "response")

# bei welcher Wahrscheinlichkeit wird als RBP klassifiziert (benötigt für den Vergleich mit RBP_nach_Score bzw mit RBP_Status)
df_complete$fitted_Status <- ifelse(df_complete$fitted_Status > 0.5, "RBP", "NO_RBP")
df_complete$fitted_Status <- factor(df_complete$fitted_Status, levels = c("NO_RBP", "RBP"))

conf_matrix <- table(
  True = df_complete$RBP_nach_Score,
  Predicted = df_complete$fitted_Status
)

colnames(conf_matrix) <- c("Vom Modell vorhergesagt: NO_RBP", "Vom Modell vorhergesagt: RBP")
rownames(conf_matrix) <- c("Klassifikation: NO_RBP", "Klassifikation: RBP")

print(conf_matrix)

TN <- 377 
FP <- 17
FN <- 143
TP <- 32

# Funktion zur Berechnung der Klassifikationsmetriken
calc_metrics <- function(TP, TN, FP, FN) {
  Gesamttrefferquote <- (TP + TN) / (TP + TN + FP + FN)
  PPW <- TP / (TP + FP)
  Sensitivität <- TP / (TP + FN)  # Sensitivität
  Spezifität <- TN / (TN + FP)
  f1_score <- 2 * (PPW * Sensitivität) / (PPW + Sensitivität)
  
  # Ergebnisse als Dataframe
  metrics_df <- data.frame(
    Metric = c("Gesamttrefferquote", "PPW", "Sensitivität", "Spezifität", "F1-Score"),
    Value = c(Gesamttrefferquote, PPW, Sensitivität, Spezifität, f1_score)
  )
  return(metrics_df)
}

Testwerte <- calc_metrics(TP, TN, FP, FN)
print(Testwerte)

```

```{r}
# Wie gut stimmt das Modell mit der Klassifikation als RBP/ NO_RBP überein -> statistisch überprüfen
# das gleiche nochmal aber für RBP_Status (aus Datenbank)

complete_idx <- complete.cases(df_ergebnisse_phys[, c("Zinc_Count", "pI")]) # Nur die Reihen ohne NA Werte 
df_complete <- df_ergebnisse_phys[complete_idx, ] # als Datenframe

# Vorhersagen durch das logistische Modell
df_complete$fitted_Status <- predict(model_logit, newdata = df_complete, type = "response")

# bei welcher Wahrscheinlichkeit wird als RBP klassifiziert (benötigt für den Vergleich mit RBP_nach_Score bzw mit RBP_Status)
df_complete$fitted_Status <- ifelse(df_complete$fitted_Status > 0.5, "RBP", "NO_RBP")
df_complete$fitted_Status <- factor(df_complete$fitted_Status, levels = c("NO_RBP", "RBP"))

conf_matrix <- table(
  True = df_complete$RBP_Status,
  Predicted = df_complete$fitted_Status
)

colnames(conf_matrix) <- c("Vom Modell vorhergesagt: NO_RBP", "Vom Modell vorhergesagt: RBP")
rownames(conf_matrix) <- c("Klassifikation: NO_RBP", "Klassifikation: RBP")

print(conf_matrix)

TN <- 378 
FP <- 47
FN <- 142 
TP <- 2

# Funktion zur Berechnung der Klassifikationsmetriken
calc_metrics <- function(TP, TN, FP, FN) {
  Gesamttrefferquote <- (TP + TN) / (TP + TN + FP + FN)
  PPW <- TP / (TP + FP)
  Sensitivität <- TP / (TP + FN)  # Sensitivität
  Spezifität <- TN / (TN + FP)
  f1_score <- 2 * (PPW * Sensitivität) / (PPW + Sensitivität)
  
  # Ergebnisse als Dataframe
  metrics_df <- data.frame(
    Metric = c("Gesamttrefferquote", "PPW", "Sensitivität", "Spezifität", "F1-Score"),
    Value = c(Gesamttrefferquote, PPW, Sensitivität, Spezifität, f1_score)
  )
  return(metrics_df)
}

Testwerte <- calc_metrics(TP, TN, FP, FN)
print(Testwerte)

```

```{r}
library(dplyr)

df_ergebnisse_phys %>%
  group_by(RBP_Status) %>%
  summarise(
    mittlerer_Zinc_Count = mean(Zinc_Count, na.rm = TRUE),
    median_Zinc_Count = median(Zinc_Count, na.rm = TRUE),
    n = n()
  ) %>%
  arrange(desc(mittlerer_Zinc_Count))

```
```{r}
library(dplyr)

df_ergebnisse_phys %>%
  group_by(RBP_Status) %>%
  summarise(
    mittlerer_pI = mean(pI, na.rm = TRUE),
    median_pI = median(pI, na.rm = TRUE),
    n = n()
  ) %>%
  arrange(desc(mittlerer_pI))

```
```{r}
df_ergebnisse_phys$Hat_Zinkfinger <- ifelse(!is.na(df_ergebnisse_phys$Zinc_Count) & df_ergebnisse_phys$Zinc_Count > 0, "ja", "nein")
table(df_ergebnisse_phys$RBP_Status, df_ergebnisse_phys$Hat_Zinkfinger)
prop.table(table(df_ergebnisse_phys$RBP_Status, df_ergebnisse_phys$Hat_Zinkfinger), 1) * 100
chisq.test(table(df_ergebnisse_phys$RBP_Status, df_ergebnisse_phys$Hat_Zinkfinger))
library(ggplot2)
```

```{r}
t.test(Zinc_Count ~ RBP_nach_Score, data = df_ergebnisse_phys)
library(ggplot2)

ggplot(df_ergebnisse_phys, aes(x = RBP_Status, y = Zinc_Count, fill = RBP_Status)) +
  geom_violin(trim = FALSE, alpha = 0.5) +
  geom_boxplot(width = 0.2, outlier.shape = NA) +
  labs(title = "Vergleich des isoelektrischen Punkts (pI) zwischen RBP und NO_RBP",
       x = "Protein-Typ", y = "pI") +
  theme_minimal()

```

# Visualisierung der logistischen Regression
```{r}
# Dichte von pI und Zinc_Count nach RBP Score
library(ggplot2)

# Zinc_Count
ggplot(df_ergebnisse_phys, aes(x = Zinc_Count, fill = RBP_nach_Score)) +
  geom_density(alpha = 0.5) +
  labs(title = "Dichteverteilung von Zinc_Count nach RBP Score",
       x = "Zinc_Count", fill = "RBP_nach_Score") +
  theme_minimal()

# pI
ggplot(df_ergebnisse_phys, aes(x = pI, fill = RBP_nach_Score)) +
  geom_density(alpha = 0.5) +
  labs(title = "Dichteverteilung von pI nach RBP Score",
       x = "Isoelektrischer Punkt (pI)", fill = "RBP_nach_Score") +
  theme_minimal()
```

```{r}
# 2D Dichteverteilung -> eventuell noch besser bei verbesserter Funktion??
df_plot <- df_ergebnisse_phys[complete.cases(df_ergebnisse_phys[, c("RBP_nach_Score", "Zinc_Count", "pI")]), ]

ggplot(df_plot, aes(x = Zinc_Count, y = pI)) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon") +
  facet_wrap(~RBP_nach_Score) +
  scale_fill_viridis_c() +
  labs(title = "2D-Dichteverteilung von Zinc_Count und pI nach RBP_Score",
       x = "Zinc_Count", y = "pI") +
  theme_minimal()
```

```{r}
# vorhergesagte Wahrscheinlichkeit (auf Basis der Regreession) für RBP anhand von pI und Zink
df_plot <- df_ergebnisse_phys[complete.cases(df_ergebnisse_phys[, c("RBP_nach_Score", "Zinc_Count", "pI")]), ]
df_plot$predicted_prob <- predict(model_logit, type = "response")

ggplot(df_plot, aes(x = Zinc_Count, y = pI, color = predicted_prob)) +
  geom_point(size = 2, alpha = 0.7) +
  scale_color_gradient(low = "#EDE6F2", high = "#394041") +
  labs(title = "Vorhergesagte Wahrscheinlichkeit für RBP",
       x = "Zink-Finger Anzahl", y = "Isoelektrischer Punkt (pI)",
       color = "P(RBP)") +
  theme_minimal()
```

```{r}
# Zusammenhang pI und Zink für RBP nach Score
ggplot(df_ergebnisse_phys, aes(x = Zinc_Count, y = pI, color = RBP_nach_Score)) +
  geom_point(alpha = 0.6) +
  labs(x = "Zink-Finger-Anzahl", y = "Isoelektrischer Punkt (pI)", color = "RBP nach Score") +
  theme_minimal()
```

```{r}
# Zusammenhang pI und Zink für RBP Status (Datenbank) 
# Regressionsmodell stimmt noch nicht sehr hiermit überein -> eventuell nach verbesserter Funktion?
ggplot(df_ergebnisse_phys, aes(x = Zinc_Count, y = pI, color = RBP_Status)) +
  geom_point(alpha = 0.6) +
  labs(x = "Zink-Finger-Anzahl", y = "Isoelektrischer Punkt (pI)", color = "RBP Status") +
  theme_minimal()
```

# Visualisieruung der Ergebnisse der Shift und RBP Klassifizierung

```{r}
library(dplyr)
library(ggplot2)

# RBP-Status zuordnen
df_ergebnisse_phys <- df_ergebnisse_phys %>%
  mutate(RBP_Gruppe = ifelse(Shift_Kategorie == "kein_shift", "non-RBP", "RBP"))

# Summen berechnen pro RBP_Gruppe + Shift_Kategorie
df_summary <- df_ergebnisse_phys %>%
  group_by(RBP_Gruppe, Shift_Kategorie) %>%
  summarise(n = n(), .groups = "drop") %>%
  mutate(
    # Kategorie-Label mit Anzahl für die Legende
    Kategorie_mit_n = paste0(Shift_Kategorie, " (", n, ")")
  )

ggplot(df_summary, aes(x = RBP_Gruppe, y = n, fill = Kategorie_mit_n)) +
  geom_col(position = "stack") +
  # Kein geom_text() → keine Zahlen in den Balken
  scale_fill_manual(
    values = setNames(
      c("#A786C2", "#8684C2", "#7396AD", "#728083","#DBCEE6"), 
      df_summary$Kategorie_mit_n
    )
  ) +
  labs(title = "Anzahl an Proteinen pro Shift-Kategorie",
       x = "Protein-Typ", y = "Anzahl Proteine", fill = "Shift-Kategorie (n)") +
  theme_minimal(base_size = 13)

```

```{r}
# Proteine, die nicht direkt an die RNA binden
# Filtere auf Proteine mit Listing_Count > 6
rbp_kandidaten <- df_ergebnisse_phys %>%
  filter(Listing_Count > 1)

# Shift_idx Statistiken
mean_shift   <- mean(rbp_kandidaten$Shift_idx, na.rm = TRUE)
sd_shift     <- sd(rbp_kandidaten$Shift_idx, na.rm = TRUE)
median_shift <- median(rbp_kandidaten$Shift_idx, na.rm = TRUE)

# Mass_kDa Statistiken
mean_masse   <- mean(rbp_kandidaten$Mass_kDa, na.rm = TRUE)
sd_masse     <- sd(rbp_kandidaten$Mass_kDa, na.rm = TRUE)
median_masse <- median(rbp_kandidaten$Mass_kDa, na.rm = TRUE)

# Ausgabe
cat("Shift_idx:\n")
cat("  Mittelwert:", mean_shift, " | Median:", median_shift, " | SD:", sd_shift, "\n\n")

cat("Mass_kDa:\n")
cat("  Mittelwert:", mean_masse, " | Median:", median_masse, " | SD:", sd_masse, "\n")

rbp_kandidaten <- rbp_kandidaten %>%
  mutate(Shift_per_kDa = Shift_idx / Mass_kDa)
# Schwellenwerte
cutoff_mass <- mean_masse
cutoff_shift <- mean_shift + sd_shift

# Potenziell indirekte RNA-abhängige Proteine
indirekt_rna_abhaengig <- df_ergebnisse_phys %>%
  filter(Mass_kDa < cutoff_mass,
         Shift_idx > cutoff_shift)
```

